# STL相关

## STL数据结构及其操作

STL详细教程：[C语言中文网](http://c.biancheng.net/stl/)

```
vector, 变长数组，倍增的思想
    size()  返回元素个数
    empty()  返回是否为空
    clear()  清空
    front()/back()
    push_back()/pop_back()
    begin()/end()
    []
    支持比较运算，按字典序

pair<int, int>
    first, 第一个元素
    second, 第二个元素
    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）

string，字符串
    size()/length()  返回字符串长度
    empty()
    clear()  清空字符串，清空后size为0
    substr(起始下标，(子串长度))  返回子串，省略子串长度或子串长度超过字符串长度，则返回起始下标之后的所有字符
    c_str()  返回字符串所在字符数组的起始地址
    pop_pack()  删除最后一个字符
    erase(起始下标，(删除长度)) 省略删除长度或删除长度超过字符串长度，则删除起始下标之后的所有字符
	stoi(字符串)  将字符串转换为int
	
queue, 队列
    size()
    empty()
    push()  向队尾插入一个元素
    front()  返回队头元素
    back()  返回队尾元素
    pop()  弹出队头元素

priority_queue, 优先队列，默认是大根堆
    push()  插入一个元素
    top()  返回堆顶元素
    pop()  弹出堆顶元素
    定义成小根堆的方式：priority_queue<int, vector<int>, greater<int>> q;

stack, 栈
    size()
    empty()
    push()  向栈顶插入一个元素
    top()  返回栈顶元素
    pop()  弹出栈顶元素

deque, 双端队列
    size()
    empty()
    clear()
    front()/back()
    push_back()/pop_back()
    push_front()/pop_front()
    begin()/end()
    []

set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列
    size()
    empty()
    clear()
    begin()/end()
    ++, -- 返回前驱和后继，时间复杂度 O(logn)
    判断某个键(map中)/值(set中)是否存在，可使用find()或者count()
    若不存在要找的键/值，则find()返回end迭代器，count()返回0
    若存在要找的键/值，则find()返回指定键/值的迭代器，count()返回此键/值的个数

    set/multiset
        insert(k)  插入一个键
        find(k)  查找一个键
        count(k)  返回某一个键的个数
        erase()
            (1) 输入是一个数x，删除所有x   O(k + logn)
            (2) 输入一个迭代器，删除这个迭代器
        lower_bound()/upper_bound()
            lower_bound(x)  返回大于等于x的最小的数的迭代器
            upper_bound(x)  返回大于x的最小的数的迭代器
    map/multimap
        insert()  插入的数是一个pair，可使用make_pair(key, val)创建pair
        erase()   输入的参数是键或者迭代器
            (1) 当参数是键时，erase() 会返回一个整数，它是移除元素的个数，所以 0 表示没有找到匹配的元素
            (2) 当参数是迭代器时，返回的迭代器指向被移除元素后的元素
        find(k)    查找一个键
        count(k)   返回某一个键的个数。map不允许重复，键不存在则为0，存在则为1；multimap中可能存在多个重复的键
        []  注意multimap不支持此操作。 时间复杂度是 O(logn)
            (1) 若不存在key则[key]会添加key，并且值初始化为0，返回0
            (2) 若存在key则[key]返回对应的值
        lower_bound()/upper_bound()

unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表
    和上面类似，增删改查的时间复杂度是 O(1)
    不支持 lower_bound()/upper_bound()， 迭代器的++，--

bitset, 圧位
    bitset<10000> s;
    ~, &, |, ^
    >>, <<
    ==, !=
    []

    count()  返回有多少个1

    any()  判断是否至少有一个1
    none()  判断是否全为0

    set()  把所有位置成1
    set(k, v)  将第k位变成v
    reset()  把所有位变成0
    flip()  等价于~
    flip(k) 把第k位取反
```

参考：[AcWing](https://www.acwing.com/blog/content/404/)



## 数组申请及初始化

### 1、使用vector

申请二维数组：

```C++
// 在函数中申请 
vector<vector<int>> dp(8, vector<int>(8, 0)); 
// 在类中申请，不可直接使用构造函数 
vector<vector<int>> dp = vector<vector<int>>(8, vector<int>(8, 0));
```

申请二维的单个字符：

```C++
// 初始化为n行n列个字符 可使用nQuee[i][j]访问各个字符
vector<string> nQuee = vector<string>(n, string(n, '.'));
```

vector重置为0：

```C++
std::fill(v.begin(), v.end(), 0);
```

类成员函数避免多次传vector，正常情况下不推荐使用：

```C++
class Solution {
public:
    vector<vector<int>> matrix;
    void demo(vector<vector<int>>& matrix) {
        this->matrix = matrix; // 使用函数传入的matrix初始化类对象中的matrix
    }
    void func() {
        matrix[0][0] = 0; // 此时操作的即为类对象中的matrix，注意：若想修改函数传入的matrix不可使用此方法
    }
};
```

#### vector使用注意事项

1、vector的存取速度比原生数组要慢很多，若能使用固定大小的数组尽量使用数组

这一点在《leetcode1091-[二进制矩阵中的最短路径](http://二进制矩阵中的最短路径)》这道题中体现的最为明显，此题中使用vector保存八个方向的话，代码很可能超时，使用原生数组存储方向耗时116ms，占用空间18MB，使用vector耗时1628ms，占用空间231.3MB。尤其要注意的是，不要在循环代码中创建临时的vector。

```
int dxy[8][2] = {{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}}; // 不会超时
vector<vector<int>> dxy = {{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}}; // 很可能超时
```

2、能使用下标遍历vector尽量使用下标，使用范围for循环会使用迭代器访问数组元素，速度也会慢一些。

总结：

1、循环中不要使用vector存储临时的数组，使用原生数组

2、尽量使用下标访问vector中的元素而不是范围for

3、元素固定的数组不要放在循环中多次创建

4、条件判断不要写太多&&，分多次判断会更加省时

对比实验：

```C++
#include <time.h>
using namespace std;
int main() {
    clock_t start,end;
    start = clock();
//    vector<vector<int>> dxy = {{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}}; // vector在循环外创建，耗时56ms
//    int dxy[8][2] = {{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}}; // 原始数组在循环外创建，耗时16ms
    for(int t = 0; t < 1000000; t++) {
        vector<vector<int>> dxy = {{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}}; // vector在循环内创建，耗时5401ms
//        int dxy[8][2] = {{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}}; // // 原始数组在循环外创建，耗时20ms
        for (int i = 0; i < 8; i++) {
            dxy[i][0] += 1;
            dxy[i][1] += 1;
        }
    }
    end = clock();
    cout << "Totle Time : " <<(double)(end - start) / CLOCKS_PER_SEC << "s" << endl;
    return 0;
}
```

### 2、使用原生数组

```C++
// 在函数中申请并初始化
int dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1};
// 在类中申请和初始化，须指定数组大小
int dx[4] = {-1,0,1,0}, dy[4] = {0,1,0,-1};
```



### 3、数组使用常见问题

Leetcode中会出现以下错误：

> runtime error: reference binding to null pointer of type 'std::vector<char, std::allocator<char> >' (stl_vector.h)

这是由于数组越界导致的，通常是因为

- 输入的vector为空，题目输入为数组时要检查是否为空
- vector未初始化

详见：[CSDN博客](https://blog.csdn.net/m0_38088298/article/details/79249044)



# 二分查找

参考：[Leetcode探索 - 二分查找](https://leetcode-cn.com/explore/learn/card/binary-search/)

## 模板1

模板 1 是二分查找的最基础和最基本的形式。这是一个标准的二分查找模板，大多数高中或大学会在他们第一次教学生计算机科学时使用。模板 #1 用于查找可以通过*访问数组中的单个索引*来确定的元素或条件。 

```C++
int binarySearch(vector<int>& nums, int target){
  if(nums.size() == 0)
    return -1;

  int left = 0, right = nums.size() - 1;
  while(left <= right){
    // Prevent (left + right) overflow
    int mid = left + (right - left) / 2;
    if(nums[mid] == target){ return mid; }
    else if(nums[mid] < target) { left = mid + 1; }
    else { right = mid - 1; }
  }

  // End Condition: left > right
  return -1;
}
```



## 模板2

模板 2 是二分查找的高级模板。它用于查找需要*访问数组中当前索引及其直接右邻居索引*的元素或条件。

```C++
int binarySearch(vector<int>& nums, int target){
  if(nums.size() == 0)
    return -1;

  int left = 0, right = nums.size();
  while(left < right){
    // Prevent (left + right) overflow
    int mid = left + (right - left) / 2;
    if(nums[mid] == target){ return mid; }
    else if(nums[mid] < target) { left = mid + 1; }
    else { right = mid; }
  }

  // Post-processing:
  // End Condition: left == right
  if(left != nums.size() && nums[left] == target) return left;
  return -1;
}
```



# 模板3

模板 3 是二分查找的另一种独特形式。 它用于搜索需要*访问当前索引及其在数组中的直接左右邻居索引*的元素或条件。

```C++
int binarySearch(vector<int>& nums, int target){
    if (nums.size() == 0)
        return -1;

    int left = 0, right = nums.size() - 1;
    while (left + 1 < right){
        // Prevent (left + right) overflow
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid;
        } else {
            right = mid;
        }
    }

    // Post-processing:
    // End Condition: left + 1 == right
    if(nums[left] == target) return left;
    if(nums[right] == target) return right;
    return -1;
}
```

