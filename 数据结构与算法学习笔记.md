# 目录

[TOC]

# 一、算法学习笔记★

## 1、基础算法

### 快速排序

#### 模板1：快排模板

此模板中仅第一处比较带等号

```C++
void qsort(int q[], int l, int r) {
    if(l >= r) return;
    int x = q[l + r >> 1], i = l - 1, j = r + 1; // 注意i,j的初始化
    while(i < j) {
        while(q[++i] < x);
        while(q[--j] > x);
        if(i < j) swap(q[i], q[j]);
    }
    qsort(q, l, j);
    qsort(q, j + 1, r);
}
```

这个模板会将数组划分为**小于等于**和**大于等于** pivot 的左右两部分[l, j]和[j + 1, r]，最后枢轴所在位置在 j 附近但不能确定具体位置，因为等于pivot的值可能出现在[l, j]范围内，也可能出现在[j + 1, r]范围内。

如果每次都选取数组最左边的元素来作为pivot，当数组已经是有序的时候每次递归数组的长度只会减少一，导致时间复杂度变为 O(n^2^)，这可以通过选中间元素作为pivot或者每次随机选取数组中一个元素与最左边的元素交换来解决，注意这里**不能用最右边**的元素作为pivot，这样如果数组最右边是最大元素的话会造成死循环。

由于划分完成后pivot不一定在这两部分的分界线上，所以在做比如得到第k大的数这种题目时不能用j - l + 1 == k来判断q[j]为第k大的数，因为左半区间只保证了所有数小于等于 pivot，而不一定都小于等于q[j]。



#### 模板2：快速选择模板

此模板与快排不同的地方在于，根据k与枢轴的位置关系，选择在左半边查找**或者**是在右半边查找

```C++
void qselect(int q[],int l,int r,int k)
{
    if(l >= r) return;
    int x = q[l + r >> 1], i = l - 1, j = r + 1;
    while(i < j) {
        while(q[++i] < x);
        while(q[--j] > x);
        if(i < j) swap(q[i], q[j]);
    }
    // 0~j有j+1个数，因而k与j+1进行比较
    if(k <= j + 1) qselect(q, l, j, k); // 第k个数在左侧
    else qselect(q, j + 1, r, k); // 第k个数在右侧
}
// 执行快速选择后q[k - 1]即为第k小的数
```

使用partition将数组划分为<=pivot和>=pivot两个部分，若pivot所处位置之前有k个数则舍弃后面的数，若pivot所处位置之前不到k个数则舍弃前面的数。模板中while循环后，j 即为pivot所在位置，注意此 j 是**相对整个数组**而不是相对某个区间，因而包括pivot在内的左侧部分元素为[0, j]，长度为 j+1，若k<=j+1则第k个数在[l, j]区间内，否则在[j + 1, r]区间内

经过快速选择后，原数组中第k个数即为所求，其下标为[k - 1]



#### 1. 快速排序

【[AcWing 785](https://www.acwing.com/problem/content/787/)】

**题解**：x为分界点，可以取数组中的任意一个值，如`q[l]、q[r]、q[l + r >> 1]`等，取中间值或者随机值可能更快一些。

递归时有两种区间分法：

- 递归写成`qsort(q, l, j);  qsort(q, j + 1, r);`时，x不可取`q[r]`，否则会无限递归

- 递归写成`qsort(q, l, i - 1);  qsort(q, i, r);`时，x不可取`q[l]`，否则会无限递归

```C++
#include <iostream>
using namespace std;

const int N = 1e6 + 10;
int q[N];

void qsort(int q[], int l, int r) {
    if(l >= r) return; // 区间中没有数，仅此处比较带等号
    
    int x = q[l + r >> 1], i = l - 1, j = r + 1; // x为分界点，i、j为指针，注意其初始化
    while(i < j) {
        while(q[++i] < x); // i指针后移直到q[i] >= x
        while(q[--j] > x); // j指针前移直到q[j] <= x
        if(i < j) swap(q[i], q[j]); // 两指针相遇，交换
    }
    
    qsort(q, l, j);
    qsort(q, j + 1, r);
}

int main() {
    int n; scanf("%d", &n);
    for(int i = 0; i < n; i++) scanf("%d", &q[i]);
    
    qsort(q, 0, n - 1);
    
    for(int i = 0; i < n; i++) printf("%d ", q[i]);
    return 0;
}
```



#### 2. 最小的k个数

【[AcWing](https://www.acwing.com/problem/content/49/)】

**题解**：套用快速选择模板即可

```C++
class Solution {
public:
    vector<int> getLeastNumbers_Solution(vector<int> input, int k) {
        vector<int> res;
        for(int i = 1; i <= k; i++) {
            qselect(input, 0, input.size() - 1, i);
            res.push_back(input[i - 1]);
        }
        return res;
    }
    
    void qselect(vector<int> &q,int l,int r,int k) {
        if(l >= r) return;
        int x = q[l + r >> 1], i = l - 1, j = r + 1;
        while(i < j) {
            while(q[++i] < x);
            while(q[--j] > x);
            if(i < j) swap(q[i], q[j]);
        }
        // 0~j有j+1个数，因而k与j+1进行比较
        if(k <= j + 1) qselect(q, l, j, k); // 第k个数在左侧
        else qselect(q, j + 1, r, k); // 第k个数在右侧
    }
};
```



### 归并排序

#### 模板1：归排模板

此模板中的所有比较操作均包含等号，其中`q[i] <= q[j]`可去除等号，但会失去稳定性。

```C++
void msort(int q[], int l, int r) {
    if(l >= r) return;
    
    int mid = l + r >> 1;
    
    msort(q, l, mid);
    msort(q, mid + 1, r);
    
    int k = 0, i = l, j = mid + 1; // 注意k需初始化为0
    while(i <= mid && j <= r) {
        if(q[i] <= q[j]) tmp[k++] = q[i++];
        else tmp[k++] = q[j++];
    }
    
    while(i <= mid) tmp[k++] = q[i++];
    while(j <= r) tmp[k++] = q[j++];
    
    for(int i = l, j = 0; i <= r; i++, j++) q[i] = tmp[j]; //注意等号
}
```



#### 1. 归并排序

【[AcWing 787](https://www.acwing.com/problem/content/789/)】

**题解**：比较`q[i]、q[j]`时可使用`q[i] <= q[j]`也可以是`q[i] < q[j]`，**加上等于时**左半边与右半边相等的数会先放到辅助数组，因而**可以保证稳定性**。

```C++
#include <iostream>
using namespace std;

const int N = 1e6 + 10;
int q[N], tmp[N];

void msort(int q[], int l, int r) {
    if(l >= r) return; // 区间中没有数
    
    int mid = l + r >> 1; // 区间中点下标
    
    msort(q, l, mid); // 排序左半边
    msort(q, mid + 1, r); // 排序右半边
    
    int k = 0, i = l, j = mid + 1; // k指向辅助数组开头，i指向左半边开头，j指向右半边开头
    while(i <= mid && j <= r) { // 比较左半边与右半边，将较小的数放到辅助数组当前位置
        if(q[i] <= q[j]) tmp[k++] = q[i++];
        else tmp[k++] = q[j++];
    }
    
    while(i <= mid) tmp[k++] = q[i++]; // 左侧未遍历完，复制
    while(j <= r) tmp[k++] = q[j++]; // 右边未遍历完，复制
    
    for(int i = l, j = 0; i <= r; i++, j++) q[i] = tmp[j]; // 从辅助数组中取出结果
}

int main() {
    int n; scanf("%d", &n);
    for(int i = 0; i < n; i++) scanf("%d", &q[i]);
    
    msort(q, 0, n - 1);
    
    for(int i = 0; i < n; i++) printf("%d ", q[i]);
    return 0;
}
```



#### 2. 逆序对的数量✏️

【[AcWing](https://www.acwing.com/problem/content/61/)】



### 二分查找

#### 模板1：整数二分模板

二分的目的：二分查找退出循环时mid指针指向目标元素

两种情况：

- 要找的数处于重复区段的最左侧。
  - 需将区间`[l, r]`划分为`[l, mid]`和`[mid + 1, r]`，从而找到重复元素区段最左侧元素所在位置
- 要找的数处于重复区段的最右侧
  - 需将区间[l, r]划分为`[l, mid - 1]`和`[mid, r]`，从而找到重复元素区段最右侧元素所在位置

注意

- 当区间被划分成`[l, mid - 1]`和`[mid, r]`时，由于除法向下取整的性质，若不进行特殊处理，则会出现无限循环。如`l = r - 1`时，若`mid = l + r >> 1`，则`mid = l`，会导致左边界一直无法更新，此时便需要将`mid`加1，即`mid = l + r + 1 >> 1`。
- 数组中不存在目标元素时，查找也能正常退出，但是最终`l`或`r`指向的元素并不等于目标数字
  - 模板bsearch_1会返回第一个比目标数字大的位置
  - 模板bsearch_1会返回第一个比目标数字的位置
- 循环退出后，`l`一定等于`r`，最终结果取`l`或者`r`没有区别

```C++
bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r) {
    while (l < r) {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
int bsearch_2(int l, int r) {
    while (l < r) {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```

使用方法：

```C++
#include <iostream>

using namespace std;

const int N = 6;
int q[N] = {1, 2, 3, 3, 4, 5};
int aim = 3;

int main() {
    // 查找第一个重复元素
    int l = 0, r = N - 1;
    while(l < r) {
        int mid = l + r >> 1;
        if(q[mid] >= aim) r = mid; // 找到大于等于aim的值，立即抛弃右侧，特殊情况就是找到等于aim的值，那么必须要抛弃右侧以获取最左侧元素
        else l = mid + 1;
    }
    cout << l << " " << r << endl;
    if(q[l] != aim) cout << "not found" << endl;
    
    // 查找最后一个重复元素
    l = 0, r = N - 1;
    while(l < r) {
        int mid = l + r + 1 >> 1;
        if(q[mid] <= aim) l = mid; // 找到小于等于aim的值，立即抛弃左侧，特殊情况就是找到等于aim的值，那么必须要抛弃左侧以获取最右侧元素
        else r = mid - 1;
    }
    cout << l << " " << r << endl;
    if(q[l] != aim) cout << "not found" << endl;
    return 0;
}
```



#### 模板2：浮点数二分模板

```C++
bool check(double x) {/* ... */} // 检查x是否满足某种性质

double bsearch_3(double l, double r) {
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l > eps) {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
```

使用方法：

```C++
#include <iostream>
using namespace std;

int main() { // 求二次方根
    int x; cin >> x;

    double l = 0, r = x;
    while(r - l > 1e-9) {
        double mid = (l + r) / 2;
        if(mid * mid  >= x) r = mid;
        else l = mid;
    }
    cout << l << endl;
    return 0;
}
```



#### 1. 数的范围

【[AcWing](https://www.acwing.com/problem/content/791/)】

**题解**：先查找第一个重复元素，再查找最后一个重复元素。

```C++
#include <iostream>

using namespace std;

const int N = 100010;
int m, n;
int q[N];

int main() {
    scanf("%d%d", &n, &m);
    for(int i = 0; i < n; i++) scanf("%d", &q[i]);
    
    while(m--) {
        int x;
        scanf("%d", &x);
        
        int l = 0, r = n - 1;
        while(l < r) {
            int mid = l + r >> 1;
            if(q[mid] >= x) r = mid;
            else l = mid + 1;
        }
        
        if(q[l] != x) cout << "-1 -1" << endl;
        else {
            cout << l << ' ';
            
            int l = 0, r = n - 1;
            while(l < r) {
                int mid = l + r + 1 >> 1;
                if(q[mid] <= x) l = mid;
                else r = mid - 1;
            }
            
            cout << l << endl;
        }
    }
    
    return 0;
}
```



#### 2. 数的三次方根

【[Acwing](https://www.acwing.com/problem/content/792/)】

**题解**：区间范围为`[-abs(x),abs(x)]`需保证 l 初始值小于0，r 初始值大于0

```C++
#include <iostream>
using namespace std;

int main() {
    double x;
    cin >> x;
    
    double l = -abs(x), r = abs(x);
    while(r - l > 1e-9) {
        double mid = (l + r) /2;
        if(mid*mid*mid >= x) r = mid;
        else l = mid;
    }
    printf("%.6f", l);
    return 0;
}
```



### 高精度

#### 1. 高精度加法

```C++
// C = A + B, A >= 0, B >= 0
vector<int> add(vector<int> &A, vector<int> &B)
{
    if (A.size() < B.size()) return add(B, A);

    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size(); i ++ )
    {
        t += A[i];
        if (i < B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }

    if (t) C.push_back(t);
    return C;
}
```



#### 2. 高精度减法

```C++
// C = A - B, 满足A >= B, A >= 0, B >= 0
vector<int> sub(vector<int> &A, vector<int> &B)
{
    vector<int> C;
    for (int i = 0, t = 0; i < A.size(); i ++ )
    {
        t = A[i] - t;
        if (i < B.size()) t -= B[i];
        C.push_back((t + 10) % 10);
        if (t < 0) t = 1;
        else t = 0;
    }

    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```



#### 3. 高精度乘法

```
// 高精度乘低精度 C = A * b, A >= 0, b > 0
vector<int> mul(vector<int> &A, int b)
{
    vector<int> C;

    int t = 0;
    for (int i = 0; i < A.size() || t; i ++ )
    {
        if (i < A.size()) t += A[i] * b;
        C.push_back(t % 10);
        t /= 10;
    }

    while (C.size() > 1 && C.back() == 0) C.pop_back();

    return C;
}
```



#### 4. 高精度除法

```C++
// 高精度除以低精度 A / b = C ... r, A >= 0, b > 0
vector<int> div(vector<int> &A, int b, int &r)
{
    vector<int> C;
    r = 0;
    for (int i = A.size() - 1; i >= 0; i -- )
    {
        r = r * 10 + A[i];
        C.push_back(r / b);
        r %= b;
    }
    reverse(C.begin(), C.end());
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```



### 前缀和与差分

**1、前缀和：**

- 前缀和的定义：有一个数组`a1,a2,...,an`，前缀和`Si = a1+a2+...+ai, S0 = 0`。前缀和的下标最好从1开始，并且S0定义为0，这样的话方便处理边界。

- 前缀和用于解决的问题：如何快速求出数组中一段数的和。例如求数组a中[l, r]区间中的和，即可使用点缀和数组快速求得，即S~l,r~ = S~r~ - S~l-1~

- 前缀和数组的创建：S~i~ = S~i-1~ + a~i~ ，时间复杂度为O(n)
- 求区间和的过程仅需要O(1)的时间复杂度

**2、差分：**

- 差分为前缀和的逆运算，有一个数组`a1,a2,...,an`，存储的是前缀和。求原数组中的各个元素bi，使得`ai = b1+b2+...+bi`，即`a`数组为`b`数组的前缀和`b`数组为`a`数组的差分。
- 公式：b~n~ = a~n~ - a~n-1~

------



#### 1. 前缀和

【[AcWing](https://www.acwing.com/problem/content/797/)】

```C++
#include <iostream>
using namespace std;

const int N = 100010;

int a[N], s[N]; // S为全局变量，S[0]默认初始化为0

int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; i++) scanf("%d", &a[i]);
    
    for(int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i]; // 前缀和的初始化
    
    while(m--) {
        int l, r;
        scanf("%d%d", &l, &r);
        printf("%d\n", s[r] - s[l - 1]); // 根据前缀和求区间和
    }
    
    return 0;
}
```



#### 2. 子矩阵的和

【[AcWing](https://www.acwing.com/problem/content/798/)】

**题解**：此题为二维前缀和

```C++
#include <iostream>
using namespace std;

const int N = 1010;
int n, m, q;
int a[N][N], s[N][N];

int main() {
    scanf("%d%d%d", &n, &m, &q);
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
            scanf("%d", &a[i][j]);
            
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
            s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j]; // 求前缀和
            
    while(q--) {
        int x1, y1, x2, y2;
        scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
        printf("%d\n", s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]); // 算子矩阵的和
    }
    
    return 0;
}
```



#### 3. 差分✏️

【[AcWing](https://www.acwing.com/problem/content/799/)】



#### 4. 差分矩阵✏️

【[AcWing](https://www.acwing.com/problem/content/800/)】



### 双指针算法

**模板1：**

```C++
for (int i = 0, j = 0; i < n; i++ ) {
    while (j < i && check(i, j)) j++;
    // 具体问题的逻辑
}
常见问题分类：
    (1) 对于一个序列，用两个指针维护一段区间
    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作
```

**模板2：**

```C++
int i = 0, j = m - 1;
while(condition) { // 如i < j
    if(check(i, j) == target) {
        // 具体问题的逻辑
        break;
    }
    if(check(i, j) > target) j--;
    else i++;
}
```

使用双指针算法能够将算法复杂度从O(n^2^)优化到O(n)，即将下面这种需要n^2^次遍历完所有情况的算法，通过两个指针的操作优化为遍历n次。

```C++
for (int i = 0; i < n; i++ ) {
    for(int j = 0; j < n; j++)
    // 具体问题的逻辑
}
```

双指针算法的特点：通常可使用**暴力解法**，若能够找到某种**单调性**，即可使用双指针进行优化。

双指针解决问题的思路：先使用暴力解法，然后看能否找到单调性，并利用单调性控制双指针移动。

------

一个简单的例子：

输入一行包含空格的字符串，按空格分割字符串并打印各子串

```
输入
abc def ghi
输出
abc
def
ghi
```

题解：i 指针不动，j 指针先找空格，找到空格从 i 开始打印，打印后 i 移动到 j 位置，之后循环中 i 会自加1，j 继续查找空格。

```C++
#include <iostream>
#include <string.h>
using namespace std;

int main() {
    char str[1000];
    cin.getline(str, 1000);
    
    int n = strlen(str);
    for(int i = 0; i < n; i++) {
        int j = i;
        while(j < n && str[j] != ' ') j++; // j指针先找到空格
        
        // 具体逻辑
        for(int k = i; k < j; k++) cout << str[k];
        cout << endl;
        
        i = j; // 打印完后i指针移动到j指针位置
    }

    return 0;
}
```



#### 1. 最长连续不重复子序列

【[AcWing](https://www.acwing.com/problem/content/801/)】

**题解**：i 指针每次右移一位，当 i 指针指向的元素在区间中出现两次时，j 指针右移直到 i 指针指向的元素在区间中仅出现一次。

```C++
#include <iostream>
using namespace std;

const int N = 100010;

int n;
int a[N], s[N];

int main() {
    cin >> n;
    for(int i = 0; i < n; i++) scanf("%d", &a[i]);
    
    int res = 0;
    for(int i = 0, j = 0; i < n; i++) { // 区间扩大
        s[a[i]]++; // 区间扩大，区间中i指向的数出现次数加1
        while(s[a[i]] > 1) {
            s[a[j]]--; // 区间缩小，j指向的数在区间中出现次数减1
            j++; // 区间缩小
        }
        res = max(res, i - j + 1);
    }
    cout << res;
    return 0;
}
```



#### 2. 数组元素的目标和

【[AcWing](https://www.acwing.com/problem/content/802/)】

**题解**：先使用暴力解法：

```C++
for(int i = 0; i < n; i++)
	for(int j = 0; j < m; j++) 
		if(a[i] + b[j] == sum) break;
```

题目给出的数组是排序数组，因而可以将指针 i 指向数组 a 的开头，将指针 j 指向数组 b 的结尾，若和大于sum则j 向左移动直到和小于等于sum，之后再向右移动 i，继续判断并操作 j。

```C++
#include <iostream>
using namespace std;

const int N = 100010;

int a[N], b[N];
int n, m, s;

int main() {
    cin >> n >> m >> s;
    for(int i = 0; i < n; i++) scanf("%d", &a[i]);
    for(int i = 0; i < m; i++) scanf("%d", &b[i]);
    
    for(int i = 0, j = m - 1; i < n; i++) {
        while(j >= 0 && a[i] + b[j] > s) j--; // 和大于目标值，左移j
        if(a[i] + b[j] == s) { // 等于目标值，输出，退出
            cout << i << " " << j << endl;
            break;
        }
    }
    return 0;
}
```

使用模板2：

```C++
int main() {
    cin >> n >> m >> s;
    for(int i = 0; i < n; i++) scanf("%d", &a[i]);
    for(int i = 0; i < m; i++) scanf("%d", &b[i]);
    
    int i = 0, j = m - 1;
    while(i < n && j >= 0) {
        if(a[i] + b[j] == s) {
            cout << i << " " << j << endl;
            break;
        }
        if(a[i] + b[j] > s) j--;
        else i++;
    }
    return 0;
}
```



### 位运算

**模板**：

```C++
求n的第k位数字: n >> k & 1 // k从0开始，n >> k 将第k位移动到第0位，&1为查看当前数字的第0位
//例如：10——1010 第3-2-1-0位分别为1-0-1-0 | 10>>3=0001,10>>2=0010,10>>1=0101,10>>0=1010

返回n的最后一位1：lowbit(n) = n & -n //例如x=1010则lowbit(x)=10,x=101000则lowbit(x)=1000
//证明：x的补码即-x, -x = ~x+1, 因而x & -x = x&(~x + 1), 进而即可得到x中最后一个1开始的所有位
    
去除最后一位1：n&(n-1)
```

n&(-n) **得到** n 的位级表示中最低的那一位 1。-n 得到 n 的反码加 1，也就是 -n=\~n+1。例如对于二进制表示 10110100，-n 得到 01001100，相与得到 00000100。

```
10110100 &
01001100
--------
00000100
```

n&(n-1) **去除** n 的位级表示中最低的那一位 1。例如对于二进制表示 01011011，减去 1 得到 01011010，这两个数相与得到 01011010。

```
01011011 &
01011010
--------
01011010
```



#### 1. 二进制中1的个数

【[AcWing](https://www.acwing.com/problem/content/803/)】

**题解**：每次减去x的最后一位1，当x等于0时停止，即可统计出x中1的个数。如1010 - 0010 = 1000，1000 - 1000 = 0000，减了两次，所以10的二进制表示1010中1的个数为2。

```C++
#include <iostream>
using namespace std;

int lowbit(int x) {
    return x & -x;
}

int main() {
    int n;
    cin >> n;
    for(int i = 0; i < n; i++) {
        int x;
        cin >> x;
        
        int res = 0;
        while(x) x -= lowbit(x), res++; // 每次减去x的最后一位1
        cout << res << ' ';
    }
    return 0;
}
```



### 离散化

**模板**：

```C++
vector<int> alls; // 存储所有待离散化的值
sort(alls.begin(), alls.end()); // 将所有值排序
alls.erase(unique(alls.begin(), alls.end()), alls.end()); // 去掉重复元素

// 二分求出x对应的离散化的值
int find(int x) // 找到第一个大于等于x的位置
{
    int l = 0, r = alls.size() - 1;
    while (l < r) {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1; // 映射到1, 2, ...n
}
```



#### 1. 区间和✏️

【[AcWing](https://www.acwing.com/problem/content/804/)】



### 区间合并

**模板**：

```C++
// 将所有存在交集的区间合并
void merge(vector<PII> &segs)
{
    vector<PII> res;

    sort(segs.begin(), segs.end());

    int st = -2e9, ed = -2e9;
    for (auto seg : segs)
        if (ed < seg.first)
        {
            if (st != -2e9) res.push_back({st, ed});
            st = seg.first, ed = seg.second;
        }
        else ed = max(ed, seg.second);

    if (st != -2e9) res.push_back({st, ed});

    segs = res;
}
```



#### 2. 区间合并✏️

【[AcWing](https://www.acwing.com/problem/content/805/)】



### C++库函数实现

#### 1. memcpy和memmove的实现

- 当src和dst区域没有重叠时，两个函数是完全一样的。否则，memcpy是不能正常工作的，memmove是可以正常工作的。
- 使用(char \*)将(void\*)转换为char型指针，从而实现逐字节复制。

```c++
void * __cdecl memcpy ( void * dst,const void * src,size_t count)
{
   void * ret = dst;
   while (count--)
   {  // 注意， memcpy函数没有处理dst和src区域是否重叠的问题
      *(char *)dst = *(char *)src;
      dst = (char *)dst + 1;
      src = (char *)src + 1;
   }
   return(ret);
}
```

```c++
void * __cdecl memmove （ void * dst,const void * src,size_t count)
{
   void * ret = dst;
   if (dst <= src || (char *)dst >= ((char *)src + count))
   {  // 若dst和src区域没有重叠，则从起始处开始逐一拷贝
      while (count--)
      {
         *(char *)dst = *(char *)src;
         dst = (char *)dst + 1;
         src = (char *)src + 1;
      }
   }
   else
   {  // 若dst和src 区域交叉，则从尾部开始向起始位置拷贝，这样可以避免数据冲突
      dst = (char *)dst + count - 1;
      src = (char *)src + count - 1;
      while (count--)
      {
         *(char *)dst = *(char *)src;
         dst = (char *)dst - 1;
         src = (char *)src - 1;
      }
   }
   return(ret);
}
```



## 2、数据结构

### 数组模拟链表

单链表通常用于邻接表中，而邻接表用于存储树和图

双链表可以用于优化某些问题



#### 模板1：数组模拟单链表

​                     `0  1  2  3  -1`

例如 `head->3->5->7->9->NULL` 

可以表示为`e[0]=3,e[1]=5,e[2]=7,e[3]=9`   `ne[0]=1,ne[1]=2,ne[2]=3,ne[3]=-1`

```C++
// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点
int head, e[N], ne[N], idx;

// 初始化
void init() {
    head = -1;
    idx = 0;
}

// 将x插入到霞表示k的节点的后面
void add_to_head(int x) {
    e[idx] = x, ne[idx] = head, head = idx++;
}

// 将头结点删除，需要保证头结点存在
void remove_head() {
    head = ne[head];
}

// 将下标是k的节点后面的节点删掉
void add(int k, int x) {
    e[idx] = x, ne[idx] = ne[k], ne[k] = idx++;
}

// 删除下标为k的节点后面的节点
void remove(int k) {
    ne[k] = ne[ne[k]];
}
```



#### 模板2：数组模拟双链表

```C++
// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点
int e[N], l[N], r[N], idx;

// 初始化
void init() {
    //0是左端点，1是右端点
    r[0] = 1, l[1] = 0;
    idx = 2;
}

// 在节点a的右边插入一个数x
void insert(int a, int x) {
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx++;
}

// 删除节点a
void remove(int a) {
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```



#### 1. 单链表

【[AcWing](https://www.acwing.com/problem/content/828/)】

```C++
#include <iostream>
using namespace std;

const int N = 100010;

// head 表示头结点的下标
// e[i] 表示节点i的值
// ne[i] 表示节点i的next指针
// idx 表示当前已经用到了哪个节点
int head, e[N], ne[N], idx;

// 初始化
void init() {
    head = -1;
    idx = 0;
}

// 将x插入到霞表示k的节点的后面
void add_to_head(int x) {
    e[idx] = x, ne[idx] = head, head = idx++;
}

// 将下标是k的节点后面的节点删掉
void add(int k, int x) {
    e[idx] = x, ne[idx] = ne[k], ne[k] = idx++;
}

// 删除下标为k的节点后面的节点
void remove(int k) {
    ne[k] = ne[ne[k]];
}

int main () {
    int m; cin >> m;
    
    init();
    while(m--) {
        int k, x;
        char op;
        
        cin >> op;
        if(op == 'H') {
            cin >> x;
            add_to_head(x);
        } else if(op == 'D') {
            cin >> k;
            if(!k) head = ne[head];
            remove(k - 1);
        } else {
            cin >> k >> x;
            add(k - 1, x);
        }
    }
    
    for(int i = head; i != -1; i = ne[i]) cout << e[i] << ' ';
    cout << endl;
    return 0;
}
```



#### 2. 双链表✏️

【[AcWing](https://www.acwing.com/problem/content/829/)】



### 数组模拟栈

```C++
// tt表示栈顶
int stk[N], tt = 0;

// 向栈顶插入一个数
stk[++tt] = x;

// 从栈顶弹出一个数
tt--;

// 栈顶的值
stk[tt];

// 判断栈是否为空
if (tt > 0) not empty
else empty
```



### 数组模拟队列

#### 模板1. 普通队列

使用数组可以直接模拟双端队列deque

```C++
// hh 表示队头，tt表示队尾
int q[N], hh = 0, tt = -1;

// 向队尾插入一个数
q[++tt] = x;

// 从队头弹出一个数
hh++;

// 队头的值
q[hh];

// 从队尾弹出一个数(deque)
tt--;

// 队尾的值(deque)
q[tt];

// 判断队列是否为空
if (hh <= tt) not empty
else empty
```



#### 模板2. 循环队列

```C++
// hh 表示队头，tt表示队尾的后一个位置
int q[N], hh = 0, tt = 0;

// 向队尾插入一个数
q[tt++] = x;
if (tt == N) tt = 0;

// 从队头弹出一个数
hh++;
if (hh == N) hh = 0;

// 队头的值
q[hh];

// 判断队列是否为空
if (hh != tt) not empty
else empty
```



### 单调栈与单调队列

#### 模板1：单调栈

```C++
// 常见模型：找出每个数左边离它最近的比它大/小的数
int tt = 0;
for (int i = 1; i <= n; i++) {
    while (tt && check(stk[tt], i)) tt--; // 栈非空，弹出
    stk[++tt] = i; // 栈顶插入元素
}
```



#### 模板2：单调队列

```C++
// 常见模型：找出滑动窗口中的最大值/最小值
int hh = 0, tt = -1;
for (int i = 0; i < n; i++) {
    while (hh <= tt && check_out(q[hh])) hh++; // 判断队头是否滑出窗口
    while (hh <= tt && check(q[tt], i)) tt--;
    q[++tt] = i;
}
```



#### 1. 单调栈

【[AcWing](https://www.acwing.com/problem/content/832/)】

**题解**：使用单调栈，复杂度为O(n)。若要找右侧比当前数小的，需要逆序遍历，即从右侧开始入栈。

```C++
#include <iostream>
using namespace std;

const int N = 100010;

int n;
int stk[N], res[N], tt = 0;

int main() {
    scanf("%d", &n);
    
    for(int i = 0; i < n; i++) { // 顺序入栈，找的是左侧的
    // for(int i = n - 1; i >= 0; i--) { // 逆序入栈，找的是右侧的
        int x;
        scanf("%d", &x);
        while(tt && stk[tt] >= x) tt--; // 栈不空，并且栈顶元素大于等于当前数，弹出栈顶
        if(tt) res[i] = stk[tt]; // 最后若栈不空，则栈顶为x左边第一个比x小的数
        else res[i] = -1; // 栈空，不存在比x小的数
        
        stk[++tt] = x; // 当前数插入队列
    }
    for(int i = 0; i < n; i++) printf("%d ", res[i]);
    return 0;
}
```



#### 2. 滑动窗口

【[AcWing](https://www.acwing.com/problem/content/156/)】

**题解**：队列中存储元素下标，主要步骤：

- 判断队头是否已经滑出窗口：窗口左端点大于队头的值（索引值），说明队头已滑出窗口，弹出队头
- 判断队尾是否需要弹出：队尾值（实际值）大于当前值，不可能是当前滑动窗口中最小值，弹出队尾
- 将当前位置索引插入队列
- 当窗口中有k个数时，开始输出

关键点：1、控制窗口大小  2、弹出不符合的元素

方法1：使用数组模拟双端队列，相当于双指针，速度快%50以上

```C++
#include <iostream>
using namespace std;

const int N = 1000010;

int n, k;
int a[N], q[N];

int main() {
    scanf("%d %d", &n, &k);
    for(int i = 0; i < n; i++) scanf("%d", &a[i]);
    
    int hh = 0, tt = -1;
    for(int i = 0; i < n ; i++) {
        if(hh <= tt && i - k + 1 > q[hh]) hh++; // 窗口左端点大于队头的值，说明队头已滑出窗口，弹出队头
        while(hh <= tt && a[q[tt]] >= a[i]) tt--; // 当前值比队尾值更小，弹出队尾
        q[++tt] = i; // 插入当前值
        if(i >= k - 1) printf("%d ", a[q[hh]]); // 窗口中有k个数，开始输出
    }
    printf("\n");
    
    hh = 0, tt = -1;
    for(int i = 0; i < n ; i++) {
        if(hh <= tt && i - k + 1 > q[hh]) hh++;
        while(hh <= tt && a[q[tt]] <= a[i]) tt--;
        q[++tt] = i;
        if(i >= k - 1) printf("%d ", a[q[hh]]);
    }
    return 0;
}
```



方法2：使用双端队列deque

```C++
#include <iostream>
#include <deque>
using namespace std;

const int N = 1000010;

int n, k;
int a[N];

int main() {
    scanf("%d %d", &n, &k);
    for(int i = 0; i < n; i++) scanf("%d", &a[i]);
    
    deque<int> dq;
    for(int i = 0; i < n ; i++) {
        if(!dq.empty() && i - k + 1 > dq.front()) dq.pop_front();
        while(!dq.empty() && a[dq.back()] >= a[i]) dq.pop_back();
        dq.push_back(i);
        if(i >= k - 1) printf("%d ", a[dq.front()]);
    }
    printf("\n");
    
    dq.clear();
    for(int i = 0; i < n ; i++) {
        if(!dq.empty() && i - k + 1 > dq.front()) dq.pop_front();
        while(!dq.empty() && a[dq.back()] <= a[i]) dq.pop_back();
        dq.push_back(i);
        if(i >= k - 1) printf("%d ", a[dq.front()]);
    }
    return 0;
}
```



### KMP

S为文本串，p为模式串，在 S 中查找与 p 完全匹配的位置。

暴力：

```C++
for(int i = 0; i < n; i++) {
    bool flag = true;
	for(int j = 0; j < m; j++) {
        if(s[i] != p[j]) {
            flag = false;
            break;
        }
    }
}
```

**next数组**：next数组仅与模式串p有关，表示的是模式串p中以当前位置结尾的子串中，前缀与后缀相等的集合中，最长前缀/后缀的长度。

例如：对于字符串”abababca”，以第6个位置结尾的子串为”ababab”，子串的前缀集合为{”a”, ”ab”, ”aba”, ”abab”, “ababa”}，后缀集合为{“babab”, ”abab”, ”bab”, ”ab”, ”b”}， 两个集合的交集为{”ab”, ”abab”}，其中最长的元素为”abab”，长度为4。那么字符串”ababacd”的next数组中第6个位置存放的数字即为4，即next[6] = 4。

”abababca”对应的next数组为{0,0,1,2,3,4,0,1}，从下标1开始存储。**注意：next数组中有0，表示不存在前缀与后缀相等。**

|  i   | next[i] |
| :--: | :-----: |
|  1   |    0    |
|  2   |    0    |
|  3   |    1    |
|  4   |    2    |
|  5   |    3    |
|  6   |    4    |
|  7   |    0    |
|  8   |    1    |

<img src="https://pic4.zhimg.com/80/v2-03a0d005badd0b8e7116d8d07947681c_720w.jpg" alt="img" style="zoom: 80%;" />

> [如何更好地理解和掌握 KMP 算法?](https://www.zhihu.com/question/21923021/answer/281346746?utm_source=qq&utm_medium=social&utm_oi=552978529109860352&hb_wx_block=1)  [KMP算法详解](https://zhuanlan.zhihu.com/p/83334559)



模板：

```C++
// s[]是长文本，p[]是模式串，ne[]是next数组，均从下标为1开始存储
// n是s的长度，m是p的长度

// 求模式串的Next数组
for (int i = 2, j = 0; i <= m; i++)
{
    while (j && p[i] != p[j + 1]) j = ne[j];
    if (p[i] == p[j + 1]) j++;
    ne[i] = j;
}

// KMP匹配
for (int i = 1, j = 0; i <= n; i++)
{
    while (j && s[i] != p[j + 1]) j = ne[j];
    if (s[i] == p[j + 1]) j++;
    if (j == m)
    {
        j = ne[j];
        // 匹配成功后的逻辑
    }
}
```



#### 1. KMP字符串

【[AcWing](https://www.acwing.com/problem/content/833/)】

**题解**：s[]是文本串，p[]是模式串，ne[]是next数组，均从下标为1开始存储，需多开1个位置的空间。

KMP匹配过程注意点：

- KMP 匹配过程中，i 遍历s串中的 1...n 位置，j 从0开始遍历到m，j=0 表示从头开始匹配模式串，j=m 表示匹配成功。s 串的第i位置每次与 p 串中的第 j+1 位置进行匹配。
- 每次比较的是s[i] 与 p[j+1]，i的取值范围为[1, n]，j的取值范围为[0, m]，i从1开始j从0开始因而每次比较的是对应位置，例如 i = 1, j = 0时比较的是s[1]和p[1]。j 除了[1,m]这m种状态，还有0这种状态，表示从模式串的头开始匹配。
- while 循环退出的原因可能为 j 回到了模式串开头，或者 s 串中当前字符与 p 串中当前字符匹配。

创建Next数组注意点：

- next 数组创建过程中，**将模式串p的后缀作为文本串，模式串自身还作为模式串**进行匹配，i 遍历模式串中的2-n位置（即后缀）。j 从0开始遍历，每次比较的是错开的两个位置，例如 i = 2, j = 0时比较的是p[2]和p[1]，相当于拿后缀与前缀的对应位置进行比较，效果就是查找与后缀匹配的前缀。
- next[1] 一定为0，表示没有前后缀（因为前后缀不包含自身），求 next 数组时 i 不可从1开始遍历

```C++
#include <iostream>

using namespace std;

const int N = 100010, M = 1000010;

int n, m;
char p[N], s[M];
int ne[N];

int main() {
    cin >> n >> p + 1 >> m >> s + 1; // 两串均从下标为1的位置开始存储
    
    // 求next数组过程
    for(int i = 2, j = 0; i <= n; i++) { // next[1]一定是0
        while(j && p[i] != p[j + 1]) j = ne[j]; // j没有退回起点0，并且匹配失败，根据next数组退回j
        if(p[i] == p[j + 1]) j++; // 循环退出后，判断是否匹配，若匹配则j可移动到下一个位置，否则判断s串下一个位置
        ne[i] = j; // 记录前缀后缀匹配的位置
    }
    
    // KMP匹配过程
    for(int i = 1, j = 0; i <= m; i++) { // i指向s串，j指向p串，s[i]与p[j+1]进行匹配
        while(j && s[i] != p[j + 1]) j = ne[j]; // j没有退回起点0，并且匹配失败，根据next数组退回j
        if(s[i] == p[j + 1]) j++; // 循环退出后，判断是否匹配，若匹配则j可移动到下一个位置，否则判断s串下一个位置
        if(j == n) { // 匹配成功
            j = ne[j]; // 继续向后匹配
            printf("%d ", i - n);
        }
    }
    return 0;
}
```



### Trie

**高效**地**存储**和**查找**字符串集合的数据结构，由一棵树和一些标记组成。

提供两种字符串操作：1、向集合中插入一个字符串  2、统计一个字符串在集合中出现了多少次

模板：

```C++
int son[N][26], cnt[N], idx;
// 0号点既是根节点，又是空节点
// son[][]存储树中每个节点的子节点
// cnt[]存储以每个节点结尾的单词数量

// 插入一个字符串
void insert(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u]) son[p][u] = ++ idx;
        p = son[p][u];
    }
    cnt[p] ++ ;
}

// 查询字符串出现的次数
int query(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}
```



#### 1. Trie字符串统计

【[AcWing](https://www.acwing.com/problem/content/837/)】

```C++
#include <iostream>
using namespace std;

const int N = 100010;

// son存储树中每个节点的子节点，cnt存储以每个节点结尾的单词的个数，idx为节点索引
int son[N][26], cnt[N], idx; // 下标是0的点，既是根节点，又是空节点

char str[N];

// 插入一个字符串
void insert(char str[]) {
    int p = 0;
    for(int i = 0; str[i]; i++) { // str[i] != '\0'
        int u = str[i] - 'a'; // 节点值，这里将字符映射到0-255
        if(!son[p][u]) son[p][u] = ++idx; // 节点p不存在值为u的子节点，创建子节点
        p = son[p][u]; // 移动到下一个节点
    }
    cnt[p]++; // 以p节点结尾的单词数量加1
}

// 查询字符串出现的次数
int query(char str[]) {
    int p = 0;
    for(int i = 0; str[i]; i++) {
        int u = str[i] - 'a';
        if(!son[p][u]) return 0; // 不存在当前单词
        p = son[p][u]; // 移动到下一节点
    }
    return cnt[p]; // 返回以p节点结尾的额单词数量
}

int main() {
    int n;
    scanf("%d", &n);
    while(n--) {
        char op[2];
        scanf("%s%s", op, str);
        if(op[0] == 'I') insert(str);
        else printf("%d\n", query(str));
    }
    return 0;
}

```



#### 2. 最大异或对✏️

【[AcWing](https://www.acwing.com/problem/content/145/)】



### 并查集

功能：1、将两个**集合合并**  2、判断两个元素**是否在一个集合**当中

基本原理：每个集合用一棵树来表示。树根的编号就是当前集合的编号。每个节点存储它的父节点，p[x]表示x的父节点

问题1：如何判断树根：if(p[x] == x)

问题2：如何求x的集合编号：找根节点。while(p[x] != x) x = p[x]

问题3：如何合并两个集合：将一个集合的根节点插入另一集合，即在一个集合的根节点处创建一个指向另一集合根节点的子节点。px是x的集合的编号，py是y的集合的编号。p[x] = y

优化：路径压缩——在向上查找根节点的过程中，可以将路径上的所有节点的父节点指针指向**根**节点，从而下次就可直接找到根节点，而不需要逐个遍历一条路径上的所有节点

模板：

```C++
(1)朴素并查集：

int p[N]; //存储每个点的祖宗节点

// 返回x的祖宗节点+路径压缩
int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

// 初始化，假定节点编号是1~n
for (int i = 1; i <= n; i ++ ) p[i] = i;

// 合并a和b所在的两个集合：
p[find(a)] = find(b);


(2)维护size的并查集：

int p[N], size[N];
//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量

// 返回x的祖宗节点+路径压缩
int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

// 初始化，假定节点编号是1~n
for (int i = 1; i <= n; i ++ )
{
    p[i] = i;
    size[i] = 1;
}

// 合并a和b所在的两个集合：
size[find(b)] += size[find(a)];
p[find(a)] = find(b);


(3)维护到祖宗节点距离的并查集：

int p[N], d[N];
//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离

// 返回x的祖宗节点+路径压缩
int find(int x)
{
    if (p[x] != x)
    {
        int u = find(p[x]);
        d[x] += d[p[x]];
        p[x] = u;
    }
    return p[x];
}

// 初始化，假定节点编号是1~n
for (int i = 1; i <= n; i ++ )
{
    p[i] = i;
    d[i] = 0;
}

// 合并a和b所在的两个集合：
p[find(a)] = find(b);
d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量
```



#### 1. 合并集合

【[AcWing](https://www.acwing.com/problem/content/838/)】

**题解**：

```C++
#include <iostream>

using namespace std;

const int N = 100010;

int n, m;
int p[N]; // 存储每个节点的祖宗节点

// 返回x的祖宗节点+路径压缩
int find(int x) {
    if(p[x] != x) x = find(p[x]); // 不是祖宗节点，继续找父节点
    return p[x];
}

int main() {
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; i++) p[i] = i; // 初始化，假定节点编号是1~n
    
    while(m--) {
        char op[2];
        int a, b;
        scanf("%s%d%d", op, &a, &b);
        
        if(op[0] == 'M') p[find(a)] = find(b); // 合并a和b所在的两个集合，即将集合a的祖宗节点的父节点设为集合b的祖宗节点
        else {
            if(find(a) == find(b)) printf("Yes\n");
            else printf("No\n");
        }
    }
    return 0;    
}
```



#### 2. 连通块中点的数量

【[AcWing](https://www.acwing.com/problem/content/839/)】

**题解**：

```C++
#include <iostream>
using namespace std;

const int N = 100010;

int n, m;
int p[N], sz[N]; // p[]存储每个节点的祖宗节点，size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量

// 返回x的祖宗节点+路径压缩
int find(int x) {
    if(p[x] != x) x = find(p[x]); // 不是祖宗节点，继续找父节点
    return p[x];
}

int main() {
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; i++) { // 初始化，假定节点编号是1~n
        p[i] = i;
        sz[i] = 1; // 初始时每个节点所在集合的点的数量为1
    }
    
    while(m--) {
        char op[4];
        int a, b;
        scanf("%s", op);
        
        if(op[0] == 'C') { // 合并a和b所在的两个集合，即将集合a的祖宗节点的父节点设为集合b的祖宗节点
            scanf("%d%d", &a, &b);
            
            if(find(a) == find(b)) continue; // a和b已经在一个集合中，跳过
            
            sz[find(b)] += sz[find(a)]; // 集合合并，size相加，维护最终祖宗节点的size即可
            p[find(a)] = find(b);
        }
        else if(op[1] == '1'){
            scanf("%d%d", &a, &b);
            
            if(find(a) == find(b)) printf("Yes\n");
            else printf("No\n");
        }
        else{
            scanf("%d%d", &a, &b);
            
            printf("%d\n", sz[find(a)]);
        }
    }
    return 0;    
}
```



#### 3. 食物链✏️

【[AcWing](https://www.acwing.com/problem/content/242/)】



### 堆

可使用一维数组存储一个堆，当首元素即堆顶元素下标为1，即数组下标从1开始存储时，下标为 x 的节点的**左儿子下标为 2x，右儿子下标为2x+1**

手写的小根堆支持的操作（heap表示存储堆的数组，size表示堆的大小）：

​	两种基本操作：down——将节点下移、up——将节点上移

1. 插入一个数

   在堆的最后一个位置插入x：heap[++size] = x

2. 求集合当中的最小值

   第一个数即为最小值：heap[1]

3. 删除最小值

   用末尾元素覆盖堆顶（即第1个元素），然后重新调整堆顶：heap[1] = heap[size]; size--; down(1)

4. 删除任意元素

   用末尾元素覆盖第k个元素，然后重新调整，可能向下也可能向上：heap[k] = heap[size]; down(k); up(k)

5. 修改任意元素

   修改第k个元素，然后重新调整，可能向下也可能向上：heap[k] = x; down(k); up(k)

插入删除时间复杂度为O(logn)，建堆的时间复杂度为O(nlogn)，但可以从n/2处执行down操作将建堆的时间复杂度降到O(n)

> 解释：最后一层节点为叶子节点，不需要进行调整（调整倒数第二层时会修改最后一层），因为最后一层的节点数量为n/2，所以n/2处即倒数第二层，从倒数第二层开始执行down操作即可建堆。

```C++
// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1
// ph[k]存储第k个插入的点在堆中的位置
// hp[k]存储堆中下标是k的点是第几个插入的
int h[N], ph[N], hp[N], size;

// 交换两个点，及其映射关系
void heap_swap(int a, int b)
{
    swap(ph[hp[a]],ph[hp[b]]);
    swap(hp[a], hp[b]);
    swap(h[a], h[b]);
}

void down(int u)
{
    int t = u;
    if (u * 2 <= size && h[u * 2] < h[t]) t = u * 2;
    if (u * 2 + 1 <= size && h[u * 2 + 1] < h[t]) t = u * 2 + 1;
    if (u != t)
    {
        heap_swap(u, t);
        down(t);
    }
}

void up(int u)
{
    while (u / 2 && h[u] < h[u / 2])
    {
        heap_swap(u, u / 2);
        u >>= 1;
    }
}

// O(n)建堆
for (int i = n / 2; i; i -- ) down(i);
```



#### 1. 堆排序

【[AcWing](https://www.acwing.com/problem/content/840/)】

```C++
#include <iostream>
using namespace std;

const int N = 100010;

int n, m;
int h[N], sz;

void down(int u) {
    int t = u; // t表示三个节点中的最小值节点的下标，t先指向根节点
    if(u*2 <= sz && h[u*2] < h[t]) t = u*2; // 有左子节点，并且左子节点的值小于当前节点的值，t指向左子节点
    if(u*2 + 1 <= sz && h[u*2 + 1] < h[t]) t = u*2 + 1; // 有右子节点，并且右子节点的值小于当前节点的值，t指向右子节点
    if(u != t) { // 最终t存的是三个节点中最小的节点的下标，若u != t即当前节点不是最小值，则当前节点的值与最小值交换
        swap(h[u], h[t]);
        down(t); // 递归调整最小值节点
    }
}

int main() {
    scanf("%d%d", &n, &m);
    for(int i = 1; i<= n; i++) scanf("%d", &h[i]);
    sz = n;
    
    for(int i = n / 2; i; i--) down(i); // 建堆
    
    while(m--) {
        printf("%d ", h[1]); // 获取堆顶元素
        // 删除堆顶
        h[1] = h[sz]; // 使用末尾元素替换堆顶
        sz--; // 大小减1
        down(1); // 从堆顶开始调堆
    }
    return 0;
}
```

补充up操作，在堆排序中不需要：

```C++
void up(int u) {
    while(u / 2 && h[u / 2] > h[u]) { // 有父节点(u/2>0)并且父节点比当前节点值大，使用当前节点值替换父节点值
        swap(h[u / 2], h[u]);
        u /= 2; // 递归调整父节点
    }
}
```



#### 2. 模拟堆

TODO：视频-第二章 数据结构（二） 1:50:21



### 哈希表

#### 模板1：一般哈希

拉链法：一维数组用于存储链表头结点，每个位置对应一个链表，将每个映射值插入对应的链表

开放寻址法：申请一个比原数据范围大2~3倍的数组，若当前位置使用了，则寻找下一位置，直到找到可插入位置

```C++
(1) 拉链法——使用N个链表
    int h[N], e[N], ne[N], idx;

    // 向哈希表中插入一个数
    void insert(int x) {
        int k = (x % N + N) % N;
        e[idx] = x, ne[idx] = h[k], h[k] = idx++; // 链表头插法
    }

    // 在哈希表中查询某个数是否存在
    bool find(int x) {
        int k = (x % N + N) % N;
        for (int i = h[k]; i != -1; i = ne[i])
            if (e[i] == x)
                return true;

        return false;
    }

(2) 开放寻址法
    int h[N];

    // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置
    int find(int x) {
        int t = (x % N + N) % N;
        while (h[t] != null && h[t] != x) {
            t ++ ;
            if (t == N) t = 0;
        }
        return t;
    }
```



#### 模板2：字符串哈希

字符串前缀哈希法：

```C++
核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低
小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果

typedef unsigned long long ULL;
ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64

// 初始化
p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
    h[i] = h[i - 1] * P + str[i];
    p[i] = p[i - 1] * P;
}

// 计算子串 str[l ~ r] 的哈希值
ULL get(int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}
```



#### 1. 模拟散列表

【[AcWing](https://www.acwing.com/problem/content/842/)】

**题解**：

方法1：拉链法

```C++
#include <iostream>
#include <cstring>
using namespace std;

const int N = 100003;

int h[N], e[N], ne[N], idx;

// 插入
void insert(int x) {
    int k = (x % N + N) % N; // 哈希函数
    e[idx] = x, ne[idx] = h[k], h[k] = idx++; // 头插法将当前数据插入到以h[k]开头的链表上
}

// 查询
bool find(int x) {
    int k = (x % N + N) % N;
    for(int i = h[k]; i != -1; i = ne[i]) // 在以h[k]开头的链表上查询x
        if(e[i] == x) // 找到x
            return true;
    return false;
}

int main() {
    int n;
    scanf("%d", &n);
    memset(h, -1, sizeof(h)); // 链表末尾为-1，表示空
    
    while(n--) {
        char op[2];
        int x;
        scanf("%s%d", op, &x);
        if(op[0] == 'I') insert(x);
        else {
            if(find(x)) printf("Yes\n");
            else printf("No\n");
        }
    }
    return 0;
}
```



方法2：开放寻址法

```C++
#include <iostream>
#include <cstring>
using namespace std;

const int N = 200003, null = 0x3f3f3f3f; // null 表示空，是一个不在数据范围内的值

int h[N], e[N], ne[N], idx;

// 查询，返回的是索引，若插入成功则返回在哈希表中的位置，否则返回需要插入的位置
int find(int x) {
    int k = (x % N + N) % N;
    
    while(h[k] != null && h[k] != x) { // 当前位置已使用，并且存储的不是x
        k++; // 寻找下一个位置
        if(k == N) k = 0; // 若找到数组末尾，调到开头
    }
    return k; // 若x在哈希表中，则k是x在哈希表中的下标；若x不在哈希表中，则k是x需要放到的位置
}

int main() {
    int n;
    scanf("%d", &n);
    memset(h, 0x3f, sizeof(h)); // 每个字节置为一个较大值，表示空
    
    while(n--) {
        char op[2];
        int x;
        scanf("%s%d", op, &x);
        
        int k = find(x); // 查询位置
        if(op[0] == 'I') h[k] = x; // 插入
        else {
            if(h[k] != null) printf("Yes\n"); // 目标位置存有合法数据
            else printf("No\n");
        }
    }
    return 0;
}
```



#### 2. 字符串哈希✏️

【[AcWing](https://www.acwing.com/problem/content/843/)】



### 树与图

#### 树与图的遍历：拓扑排序

#### 最短路

#### 最小生成树

#### 二分图：染色法、匈牙利算法

### C++ STL使用技巧



## 3、搜索

### DFS与BFS概述

深度优先搜索和广度优先搜索广泛运用于树和图中，但是它们的应用远远不止如此

**1、深度优先搜索 DFS**

- 数据结构：使用stack
- 空间：O(n)
- 不具有最短性
- DFS中有回溯、剪枝
- 适用于对空间要求比较高，比较复杂的题

典型案例：排列、N皇后

**2、广度优先搜索 BFS**

- 数据结构：使用queue

- 空间：O(2^n^)，空间为指数级，比DFS大很多

- 具有最短性

- 适用于找最短路径的题

  典型案例：迷宫问题 、二进制矩阵中的最短路径

  代码框架：

    ```C++
    void BFS()
    {
        queue<int> qu; // 定义队列
        vector<vector<int>> memo(m, vector<int>(n,0)); // 定义备忘录，用于记录已经访问的位置

        if(condition) return; // 判断边界条件，是否能直接返回结果

        qu.push(start); // 将起始位置加入到队列中
        memo[0][0] = 1; // 更新备忘录。

        while (!qu.empty()) {
            int cnt = qu.size(); // 获取当前队列中的节点个数
            while(cnt--) { // 遍历一层
                auto t = qu.front(); // 取队头
                qu.pop(); // 队头出队
                if(condition) { // 判断是否到达终点位置
                    // 某些输出或返回操作
                }
                // 根据某些条件获取下一层所有的节点
                if(condition) { // 条件判断，过滤掉不符合条件的位置
                    qu.push(); // 下一层节点入队
                }
            }
        }
    }
    ```

**3、对比**

- 两者均需标记已搜索过的点
- DFS的代码量相对BFS少一些
- DFS中第一句通常为递归边界（迷宫），或者返回值定义（红与黑）
- 路径点标记：
  - DFS中**仅有一处标记代码，不仅可标记起点，而且可标记新加入的点**
  - BFS中**有两处标记代码，先标记起点，加入新点时也需标记**
- 状态更新：
  - DFS中使用当前函数的输入参数更新状态
  - BFS使用队列中取出的参数更新状态
- 非法点判断：
  - 在DFS中标记起点前要进行合法性判断，此处**不仅可判断起点的合法性，也可以判断之后各点的合法性。加入新点时可不进行合法性判断**
  - 在BFS中标记起点前要进行合法性判断，但此处**仅能判断起点的合法性，之后加入新点的合法性要单独进行判断**

------

### BFS

#### 1. Flood Fill模型

##### 1、池塘计数

【[AcWIng 1097](https://www.acwing.com/solution/AcWing/content/5859/)】池塘计数，改编自Leetcode [733. 图像渲染](https://leetcode-cn.com/problems/flood-fill/)

农夫约翰有一片 N∗M 的矩形土地。最近，由于降雨的原因，部分土地被水淹没了。现在用一个字符矩阵来表示他的土地。每个单元格内，如果包含雨水，则用”W”表示，如果不含雨水，则用”.”表示。现在，约翰想知道他的土地中形成了多少片池塘。每组相连的积水单元格集合可以看作是一片池塘。每个单元格视为与其**上、下、左、右、左上、右上、左下、右下**八个邻近单元格相连。请你输出共有多少片池塘，即矩阵中共有多少片相连的”W”块。

> 输入格式：第一行包含两个整数 N 和 M。接下来 N 行，每行包含 M 个字符，字符为”W”或”.”，用以表示矩形土地的积水状况，字符之间没有空格。1≤N,M≤1000。
>
> 输出格式：输出一个整数，表示池塘数目。
>

```
输入
10 12
W........WW.
.WWW.....WWW
....WW...WW.
.........WW.
.........W..
..W......W..
.W.W.....WW.
W.W.W.....W.
.W.W......W.
..W.......W.
输出
3
```



**题解**：

方法1：使用BFS，好处是不会爆栈。每次找到一个池塘中的点，然后搜索周围的池塘点，并做标记。下次再搜索未标记的池塘点，所有池塘点搜索完即可获得连通的池塘个数。

```C++
#include <iostream>
#include <queue>

using namespace std;

const int N = 1010;
int m, n;
char g[N][N];
int st[N][N];
queue<pair<int, int>> qu;

void bfs(int x, int y) {
    qu.push({x, y});
    st[x][y] = 1;

    while(!qu.empty()) {
        auto t = qu.front();
        qu.pop();

        // 搜索周围的八个点
        for(int i = -1; i < 2; i++) {
            for(int j = -1; j < 2; j++) {
                int xx = t.first + i, yy = t.second + j;
                if(i == 0 && j == 0) continue; // 跳过当前所在点
                if(xx < 0 || xx >= m || yy < 0 || yy >= n) continue;
                if(g[xx][yy] == '.' || st[xx][yy] == 1) continue; // 跳过非池塘点及搜索过的点


                qu.push({xx, yy}); // 加入新点
                st[xx][yy] = 1; // 记录
            }
        }
    }
}

int main() {
    char c;
    cin >> m >> n;
    for(int i = 0; i < m; i++) {
        for(int j = 0; j < n; j++) {
            cin >> c;
            g[i][j] = c;
        }
    }

    int res = 0; // 连通区域计数
    for(int i = 0; i < m; i++) {
        for(int j = 0; j < n; j++) {
            if(g[i][j] == 'W' && st[i][j] == 0) { // 当前点是池塘中的点，并且没有搜到过
                bfs(i, j); // 从当前点开始搜索附近连通的区域，并标记搜索到的池塘点，保证下次搜到的池塘点属于另一片池塘
                res++; // 连通区域数量加1
            }
        }
    }
    cout << res << endl;

    return 0;
}
```



##### 2、城堡问题



##### 3、山峰和山谷



#### 2. 最短路模型

##### 1、迷宫问题

【[nowcoder](https://www.nowcoder.com/questionTerminal/cf24906056f4488c9ddb132f317e03bc?orderByHotValue=0&commentTags=C/C++) / [AcWing 1076](https://www.acwing.com/solution/AcWing/content/6692/)】定义一个二维数组N*M（其中2<=N<=10;2<=M<=10），如5 × 5数组下所示：   

```C++
int maze[5][5] = {  
    0, 1, 0, 0, 0,  
    0, 1, 0, 1, 0,  
    0, 0, 0, 0, 0,  
    0, 1, 1, 1, 0,  
    0, 0, 0, 1, 0,  
};
```

它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的**最短路线**。入口点为[0,0],既第一空格是可以走的路。

```
输入两个整数，分别表示二位数组的行数，列数。再输入相应的数组，其中的1表示墙壁，0表示可以走的路。
数据保证有唯一解,不考虑有多解的情况，即迷宫只有一条通道。
5 5
0 1 0 0 0
0 1 0 1 0
0 0 0 0 0
0 1 1 1 0
0 0 0 1 0

输出左上角到右下角的最短路径
(0,0)
(1,0)
(2,0)
(2,1)
(2,2)
(2,3)
(2,4)
(3,4)
(4,4)
```

**题解**：求最短路径，必然使用广度优先搜索

```C++
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

int m, n;
vector<vector<int>> maze; // 迷宫
vector<vector<int>> dis; // 到起点的距离
queue<pair<int, int>> loc; // 坐标
vector<vector<pair<int, int>>> path;

int bfs() {
    loc.push({0, 0}); // 初始化队列，放入起始坐标
    dis[0][0] = 0; // 标记起点距离
    
    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
    while(!loc.empty()) {
        auto t = loc.front();
        loc.pop();

        for(int i = 0; i < 4; i++) { // 四个方向
            int x = t.first + dx[i], y = t.second + dy[i];
            // 不是障碍物，并且没走过
            if(x >= 0 && x < m && y >= 0 && y < n && maze[x][y] == 0 && dis[x][y] == -1){
                dis[x][y] = dis[t.first][t.second] + 1; // 距离标记
                loc.push({x, y}); // 将可行坐标放入队列
                path[x][y] = t; // 记录之前走过的位置
            }
        }
    }
    
    // 从终点向前找之前走过的路径
    int x = m - 1, y = n -1;
    vector<pair<int, int>> tpath;
    tpath.push_back({x, y}); // 保存终点位置
    while(x || y) { // x、y不越界
        auto t = path[x][y]; // 获取前一位置
        tpath.push_back(t); // 保存前一位置
        x = t.first, y = t.second;
    }
    for(int i = tpath.size() - 1; i >= 0; i--)
        cout << '(' << tpath[i].first << ',' << tpath[i].second << ')' << endl;
    
    return dis[m - 1][n - 1];
}

int main() {
    while(cin >> m >> n) { // 处理多个case
        maze = vector<vector<int>>(m, vector<int>(n)); // 初始化迷宫
        dis = vector<vector<int>>(m, vector<int>(n, -1)); // 初始化距离标记
        path = vector<vector<pair<int, int>>>(m, vector<pair<int, int>>(n));
        for(int i= 0; i < m; i++){ // 输入迷宫
            for(int j = 0; j < n; j++) {
                cin >> maze[i][j];
            }
        }
        int minDis = bfs();
    }
    return 0;
} 
```



为便于输出路径，可从右下角开始搜索

```C++
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

int m, n;
vector<vector<int>> maze; // 迷宫
vector<vector<int>> dis; // 到起点的距离
queue<pair<int, int>> loc; // 坐标
vector<vector<pair<int, int>>> path;

int bfs(int sx, int sy) {
    loc.push({sx, sy}); // 初始化队列，放入起始坐标
    dis[sx][sy] = 0; // 标记起点距离
    
    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
    while(!loc.empty()) {
        auto t = loc.front();
        loc.pop();

        for(int i = 0; i < 4; i++) { // 四个方向
            int x = t.first + dx[i], y = t.second + dy[i];
            // 不是障碍物，并且没走过
            if(x < 0 || x >= m || y < 0 || y >= n) continue;
            if(maze[x][y] != 0) continue;
            if(dis[x][y] != -1) continue;
            
            dis[x][y] = dis[t.first][t.second] + 1; // 距离标记
            loc.push({x, y}); // 将可行坐标放入队列
            path[x][y] = t; // 记录之前走过的位置
        }
    }
    
    // 从终点（左上角点）开始找之前走过的路径
    pair<int, int> end(0, 0);
    while(true) {
        cout << '(' << end.first << ',' << end.second << ')' << endl;
        if(end.first == m - 1 && end.second == n - 1) break;
        end = path[end.first][end.second];
    }
    return dis[m - 1][n - 1];
}

int main() {
    while(cin >> m >> n) { // 处理多个case
        maze = vector<vector<int>>(m, vector<int>(n)); // 初始化迷宫
        dis = vector<vector<int>>(m, vector<int>(n, -1)); // 初始化距离标记
        path = vector<vector<pair<int, int>>>(m, vector<pair<int, int>>(n));
        for(int i= 0; i < m; i++){ // 输入迷宫
            for(int j = 0; j < n; j++) {
                cin >> maze[i][j];
            }
        }
        int minDis = bfs(m - 1, n - 1); // 为便于输出路径，从终点开始搜索
    }
    return 0;
} 
```

##### 2、武士风度的牛



##### 3、抓住那头牛



#### 3. 多源BFS

##### 1、矩阵距离

【[AcWing 173](https://www.acwing.com/problem/content/175/)】给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 1 的距离。

改编自 [Leetcode 542. 01 矩阵](https://leetcode-cn.com/problems/01-matrix/)

```
输入样例：
3 4
0001
0011
0110

输出样例：
3 2 1 0
2 1 0 0
1 0 0 1
```

**题解**：

```C++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>

#define x first 
#define y second

using namespace std;
const int N = 1010, M = N * N;

int dx[4] = {-1, 1, 0, 0};
int dy[4] = {0, 0, -1, 1};

int n, m;
char g[N][N];
int d[N][N];
queue<pair<int,int>> q;

void bfs()
{
    memset(d, -1, sizeof d);
    
    for(int i = 0; i < n; ++i)
        for(int j = 0; j < m; ++j)
            if(g[i][j] == '1')
                q.push({i, j}), d[i][j] = 0;
            
    while(!q.empty()) {
        auto t = q.front();
        q.pop();
        for(int i = 0; i < 4; ++i) {
            int nx = t.x + dx[i], ny = t.y + dy[i];
            
            if(nx < 0 || nx >= n || ny < 0 || ny >= m)  continue;
            if(d[nx][ny] != -1) continue;
            
            q.push({nx, ny});
            d[nx][ny] = d[t.x][t.y] + 1;
        }
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    for(int i = 0; i < n; ++i)  scanf("%s", g[i]);
    
    bfs();
    
    for(int i = 0; i < n; ++i)
    {
        for(int j = 0; j < m; ++j)  printf("%d ", d[i][j]);
        puts("");
    }
    
    return 0;
}
```



#### 4. 最小步数模型

##### 1、八数码

【[nowcoder](https://www.nowcoder.com/questionTerminal/c958afdfd23b464fab907a2ba6d5f2a1?f=discussion) / [Acwing 845](https://www.acwing.com/problem/content/847/)】八数码问题，就是在一个含有1-8和x的3*3方格中，每次可以将x与其相邻位置（上下左右）的数字交换。

```
1 2 3
x 4 6
7 5 8
```

使得最后变成

```
1 2 3
4 5 6
7 8 x
```

交换过程如下：

```
1 2 3   1 2 3   1 2 3   1 2 3
X 4 6   4 X 6   4 5 6   4 5 6
7 5 8   7 5 8   7 X 8   7 8 X
```

你要做的就是实现八数码的解决方案，并要求**交换次数最少**。

```
输入一个3*3的矩阵，包含1-8和x
2  3  4  
1  5  x  
7  6  8
输出需要移动的步数，如果不可能实现，输出-1
19
```

**题解**：

可将每一种8数码当成图中的一个节点，通过广度优先搜索即可找到从一种8数码转换到另一种8数码的最短路径，每一种8数码表示一种状态，也即图中的一个节点。这道题的状态表示比较复杂，而且如何记录每个状态到初始状态的距离也是个问题。

状态表示：将9个格子展开，形成一个string以表示状态，如“123x46758”

各状态的距离：unordered_map记录当前的字符串和步数，如果string是目标状态，那么返回步数。

```C++
#include <iostream>
#include <unordered_map>
#include <string>
#include <queue>
using namespace std;

int bfs(string start) {
    string end = "12345678x"; //记录最后一个状态
    queue<string> qu;
    unordered_map<string, int> dis; // 存储当前状态到下一状态的距离
    
    qu.push(start); //将初始状态加入队列
    dis[start] = 0;
    
    int dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1};
    while(!qu.empty()) {
        auto t = qu.front();
        qu.pop();
        
        int distance = dis[t];
        if(t == end) return distance;
        
        // 状态转移
        int k = t.find('x'); // 字符串表示中找x
        int x = k / 3, y = k % 3;  // 一维转化为二维
        for(int i = 0; i < 4; i++) {
            int xx = x + dx[i], yy = y + dy[i];
            if(xx >= 0 && xx < 3 && yy >= 0 && yy < 3) {
                swap(t[k], t[xx * 3 + yy]); // 二维转化为一维
                if(!dis.count(t)) { // 如果没有出现过当前状态
                    dis[t] = distance + 1;
                    qu.push(t);
                }
                swap(t[k], t[xx * 3 + yy]); //恢复现场
            }
        }
    }
    return -1; // 无法实现
}

int main() {
    string start;
    char c;
    for(int i = 0; i < 9; i++) {
        cin >> c;
        start += c;
    }
    cout << bfs(start) << endl;
    return 0;
}
```



##### 2、魔板



#### 5. 双端队列广搜

##### 1、电路维修



#### 6. 双向广搜

双向广搜适用于**已知终点**的情况，并且适用于**最小步数模型**这种要搜索的节点数量很大的情况，不适用于FloodFill及最短路模型这种节点数量较少的情况。

##### 1、字串变换

【[AcWing 190](https://www.acwing.com/problem/content/192/)】已知有两个字串 AA, BB 及一组字串变换的规则（至多6个规则）:

A1A1 -> B1B1

A2A2 -> B2B2

…

规则的含义为：在 AA 中的子串 A1A1 可以变换为 B1B1、A2A2 可以变换为 B2B2 …。

例如：AA＝’abcd’ BB＝’xyz’

变换规则为：

‘abc’->‘xu’ ‘ud’->‘y’ ‘y’->‘yz’

则此时，AA 可以经过一系列的变换变为 BB，其变换的过程为：

‘abcd’->‘xud’->‘xy’->‘xyz’

共进行了三次变换，使得 AA 变换为BB。

> 输入格式
>
> 输入格式如下：
>
> AA BB
> A1A1 B1B1 \
> A2A2 B2B2 |-> 变换规则
> … … /
>
> 所有字符串长度的上限为 20。
>
> 输出格式
>
> 若在 10 步（包含 10步）以内能将 AA 变换为 BB ，则输出最少的变换步数；否则输出”NO ANSWER!”
>

```
输入样例：
abcd xyz
abc xu
ud y
y yz

输出样例：
3
```

**题解**：使用双向广搜，相似题目：[Leetcode 127. 单词接龙](https://leetcode-cn.com/problems/word-ladder/)

```C++
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>
#include <unordered_map>

using namespace std;

const int N = 6;

int n;
string a[N], b[N];


int bfs(string A, string B)
{
    queue<string> qa, qb;
    unordered_map<string, int> da, db;

    qa.push(A), da[A] = 0;
    qb.push(B), db[B] = 0;

    while (qa.size() && qb.size())
    {
        if(qa.size() > qb.size()) { // 保证扩展较短队列
            swap(qa, qb);
            swap(da, db);
            swap(a, b);
        }
        auto t = qa.front();
        qa.pop();
    
        for (int i = 0; i < t.size(); i ++ )
            for (int j = 0; j < n; j ++ )
            {
                if (t.substr(i, a[j].size()) != a[j]) continue;
                string r = t.substr(0, i) + b[j] + t.substr(i + a[j].size());
                if (db.count(r)) return db[r] + da[t] + 1;
                if (da.count(r)) continue;
    
                da[r] = da[t] + 1;
                qa.push(r);
        }
    }

    return 11;
}

int main()
{
    string A, B;
    cin >> A >> B;

    while (cin >> a[n] >> b[n]) n ++ ;

    int step = bfs(A, B);
    if (step > 10) puts("NO ANSWER!");
    else printf("%d\n", step);

    return 0;
}
```



#### 7. A*

##### 1、第K短路

##### 2、八数码



### DFS

DFS可分为两大类模型：

- **内部搜索**，即在一个网格/图的内部进行搜索，**不需要恢复现场**，如连通性问题。
- **外部搜索**，即在网格之间进行搜索，网格相当于图中的节点，**需要恢复现场**

DFS中：

- dfs函数开头通常需要进行**搜索终点判断**
- dfs函数开头还可能需要进行**合法性检查**
  - 在连通性模型（内部搜索）中合法性检查最好放在开头，而不是即将搜索下一点时，因为起点可能就是非法的。当然，两个地方都进行判断也是可以的
  - 其他模型（外部搜索）通常在即将搜索下一点时进行合法性检查
- dfs中可重复的资源不需要设置**备忘录**，否则需要。如小猫爬山问题中缆车可重复使用，不需要设置备忘录。在全排列问题中，每个数字仅能使用一次的话，就需要使用备忘录

------



#### 1. 连通性模型

用于FloodFill、树与图的遍历等，通常是在一个网格/图的**内部**，判断能否从一个点走到到另一个点。其余的DFS模型通常是在两个网格/图**之间**，判断能否从一种网格/图（状态）转换为另一种网格/图（状态）。

- 连通性模型中，**DFS用于判断能否从一个点走到另一个点，而BFS不仅能判断能否从一个点走到另一个点，还能得到最短距离**。例如迷宫问题，DFS仅能判断能否到达终点，而BFS还能计算到达终点的最短距离/路径。
- DFS相比于BFS代码较短，并且通常空间复杂度较低，但系统栈空间是1M，数据量大时会爆栈。
- 连通性模型这种在网格/图**内部搜索**的问题，不需要也**不能恢复现场，因为需要保证每个点搜索一次**。但其他模型中，把网格/图当成一种状态，需要判断能否从一种状态转变成另一种状态，此时需要把网格/图**恢复成原来的状态，才能够去搜索下一个分支**。

------

##### 1、迷宫

【[AcWing 1112](https://www.acwing.com/solution/AcWing/content/6788/)】一天Extense在森林里探险的时候不小心走入了一个迷宫，迷宫可以看成是由  n∗n  的格点组成，每个格点只有2种状态，`.`和`#`，前者表示可以通行后者表示不能通行。

同时当Extense处在某个格点时，他只能移动到东南西北(或者说上下左右)四个方向之一的相邻格点上，Extense想要从点A走到点B，问在不走出迷宫的情况下能不能办到。如果起点或者终点有一个不能通行(为#)，则看成无法办到。注意：A、B不一定是两个不同的点。

> 输入格式
> 第1行是测试数据的组数  k ，后面跟着  k  组输入。
>
> 每组测试数据的第1行是一个正整数  n ，表示迷宫的规模是  n∗n  的。
>
> 接下来是一个  n∗n  的矩阵，矩阵中的元素为.或者#。
>
> 再接下来一行是 4 个整数  ha,la,hb,lb ，描述  A  处在第  ha  行, 第  la  列， B  处在第  hb  行, 第  lb  列。
>
> 注意到  ha,la,hb,lb  全部是从 0 开始计数的。
>
> 输出格式
> k行，每行输出对应一个输入。能办到则输出“YES”，否则输出“NO”。
>
> 数据范围1≤n≤100 

```
输入：
3
3
.##
..#
#..
0 0 2 2
3
###
..#
#..
0 0 2 2
5
.....
###.#
..#..
###..
...#.
0 0 4 0

输出：
YES
NO
NO
```

**题解**：判断从起点是否可以走到终点，属于网格的遍历。此题既可使用DFS也可使用BFS，需要注意的是两者均需**对起点合法性进行判断**。

DFS和BFS对比：

- 两者均需标记已搜索过的点
- DFS的代码量相对BFS少一些
- DFS中第一句通常为递归边界，或者返回值定义（可见下一题：红与黑）
- 路径点标记：
  - DFS中`st[x][y] = 1;`不仅可标记起点，而且可标记新加入的点
  - BFS中先`st[x][y] = 1;`标记起点，加入新点时还需`st[x][y] = 1;`标记
- 状态更新：
  - DFS中使用当前函数的输入参数更新状态，例如`int a = x + dx[i], b = y + dy[i];`
  - BFS使用队列中取出的参数更新状态，例如`int a = t.first + dx[i], b = t.second + dy[i];`
- 非法点判断：
  - 可参考两种代码中`if(g[x][y] == '#')`语句的位置
  - 在DFS中在标记起点前进行第一处合法性判断：`if(g[x][y] == '#') return false;`**不仅可判断起点的合法性，也可以判断之后各点的合法性**，后面第二处合法性判断：`if(g[a][b] == '#') continue;`**可省略**
  - 在BFS中在标记起点前进行第一处合法性判断：`if(g[x][y] == '#') return false;`**仅能判断起点的合法性，之后各点的合法性也要进行合法性判断**：`if(g[a][b] == '#') continue;`**不可省略**

```C++
#include <iostream>
#include <cstring>
using namespace std;

const int N = 110;
int n;

char g[N][N];
int st[N][N];
int xa, ya, xb, yb;

int dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1};

bool dfs(int x, int y) {
    if(x == xb && y == yb) return true; // 搜到终点了

    if(g[x][y] == '#') return false; // 先判断起点合法性，实际就是判断所有点的合法性
    st[x][y] = 1; // 标记搜过的点

    for(int i = 0; i < 4; i++) { // 枚举上下左右的点
        int a = x + dx[i], b = y + dy[i];
        if(a < 0 || a >= n || b < 0 || b >= n) continue;
        if(st[a][b]) continue; // 跳过搜过的点
        //if(g[a][b] == '#') continue; // 判断下一点合法性，若开头就判断合法性，此处可省略
        if(dfs(a, b)) return true; // 从一个合法点开始搜
    }
    return false;
}

#include <queue>
bool bfs(int x, int y) {
    queue<pair<int ,int>> qu;

    if(g[x][y] == '#') return false; // 先判断起点合法性
    qu.push({x, y});
    st[x][y] = 1; // 标记起点

    while(!qu.empty()) {
        auto t= qu.front();
        qu.pop();

        if(t.first == xb && t.second == yb) return true; // 找到终点

        for(int i = 0; i < 4; i++) { // 枚举上下左右的点
            int a = t.first + dx[i], b = t.second + dy[i]; // 注意与dfs的区别
            if(a < 0 || a >= n || b < 0 || b >= n) continue;
            if(st[a][b]) continue; // 跳过搜过的点
            if(g[a][b] == '#') continue; // 判断下一点合法性

            qu.push({a, b}); // 合法的点加入队列
            st[a][b] = 1; // 标记搜过的点
        }
    }
    return false;
}

int main() {
    int k;
    cin >> k;
    while(k--){
        cin >> n;
        for(int i = 0; i < n; i++) scanf("%s", g[i]);
        cin >> xa >> ya >> xb >> yb;
        memset(st, 0, sizeof(st));
        // DFS
        if(dfs(xa, ya)) puts("YES");
        else puts("NO");
        // BFS
//        if(bfs(xa, ya)) puts("YES");
//        else puts("NO");
    }
    return 0;
}
```



##### 2、红与黑

【[AcWing 1113](https://www.acwing.com/solution/AcWing/content/6394/)】有一间长方形的房子，地上铺了红色、黑色两种颜色的正方形瓷砖。你站在其中一块黑色的瓷砖上，只能向相邻（上下左右四个方向）的黑色瓷砖移动。请写一个程序，计算你总共能够到达多少块黑色的瓷砖。

> 输入格式
> 输入包括多个数据集合。
> 每个数据集合的第一行是两个整数 W 和 H，分别表示 x 方向和 y 方向瓷砖的数量。
> 在接下来的 H 行中，每行包括 W 个字符。每个字符表示一块瓷砖的颜色，规则如下
> 1）‘.’：黑色的瓷砖；
> 2）‘#’：白色的瓷砖；
> 3）‘@’：黑色的瓷砖，并且你站在这块瓷砖上。该字符在每个数据集合中唯一出现一次。
> 当在一行中读入的是两个零时，表示输入结束。
>
> 输出格式
> 对每个数据集合，分别输出一行，显示你从初始位置出发能到达的瓷砖数(记数时包括初始位置的瓷砖)。
>
> 数据范围1≤W,H≤20

```
输入样例：
6 9
....#.
.....#
......
......
......
......
......
#@...#
.#..#.
0 0
输出样例：
45
```

**题解**：属于FloodFill模型，计算连通区域中的点数

```C++
#include <iostream>
#include <cstring>
using namespace std;

const int N = 25;
int m, n;

char g[N][N];
int st[N][N];

int dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1};

int dfs(int x, int y) {
    int cnt = 1; // 注意，每个点的cnt贡献为1

    if(g[x][y] == '#') return 0; // 合法性检查
    st[x][y] = 1;

    for(int i = 0; i < 4; i++) {
        int a = x + dx[i], b = y + dy[i];
        if(a < 0 || a >= m || b < 0 || b >= n) continue;
        if(st[a][b]) continue;
//        if(g[a][b] == '#') continue; // 合法性检查，可省略

        cnt += dfs(a, b);
    }
    return cnt;
}

#include <queue>
int bfs(int x, int y) {
    queue<pair<int, int>> qu;

    if(g[x][y] == '#') return 0; // 检查起点合法性
    qu.push({x, y});
    st[x][y] = 1;

    int cnt = 1;
    while(!qu.empty()) {
        auto t = qu.front();
        qu.pop();

        for(int i = 0; i < 4; i++) {
            int a = t.first + dx[i], b = t.second + dy[i]; // 注意与dfs的区别
            if(a < 0 || a >= m || b < 0 || b >= n) continue;
            if(st[a][b]) continue;
            if(g[a][b] == '#') continue; // 合法性检查

            qu.push({a, b});
            st[a][b] = 1;
            cnt++; // 记录加入的点数
        }
    }
    return cnt;
}

int main() {
    while(cin >> n >> m && m || n) {
        for (int i = 0; i < m; i++) cin >> g[i];

        int x, y;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (g[i][j] == '@') {
                    x = i;
                    y = j;
                }
            }
        }

        memset(st, 0, sizeof(st));
//        cout << dfs(x, y) << endl;
        cout << bfs(x, y) << endl;
    }

    return 0;
}
```



#### 2. DFS搜索顺序

##### 1、马走日

【[AcWIng 1116](https://www.acwing.com/solution/AcWing/content/6795/)】马在中国象棋以日字形规则移动。请编写一段程序，给定 n∗m 大小的棋盘，以及马的初始位置 (x，y)，要求不能重复经过棋盘上的同一个点，计算马可以有多少途径遍历棋盘上的所有点。

> 输入格式
> 第一行为整数 T，表示测试数据组数。每一组测试数据包含一行，为四个整数，分别为棋盘的大小以及初始位置坐标 n,m,x,y。
>
> 输出格式
> 每组测试数据包含一行，为一个整数，表示马能遍历棋盘的途径总数，若无法遍历棋盘上的所有点则输出 0。
>
> 数据范围
> 1≤T≤9,
> 1≤m,n≤9,
> 0≤x≤n−1,
> 0≤y≤m−1

```
输入样例：
1
5 4 0 0

输出样例：
32
```

**题解**：此题为外部搜索，即整个网格为一个状态，需要将整个网格当做图中的节点，在网格之间进行搜索，**需要恢复现场**

```C++
#include <iostream>
#include <cstring>
using namespace std;

const int N = 15;

bool st[N][N];
int res;
int n, m;

int dx[8] = {-1,-2,-2,-1,1,2,2,1}, dy[8] = {-2,-1,1,2,2,1,-1,-2};

void dfs(int x, int y, int cnt)
{
    if(cnt == m*n) { // 走了m*n步，即搜索到了所有的点
        res ++;
        return;
    }

    st[x][y] = true; // 标记

    for(int i = 0; i < 8; i++) {
        int a = x + dx[i], b = y + dy[i];
        if(a < 0 || a >= m || b < 0 || b >= n) continue;
        if(st[a][b]) continue;

        dfs(a, b, cnt + 1);
    }

    st[x][y] = false; // 需要恢复现场
}

int main() {
    int T;
    cin >> T;
    while(T--) {
        int x, y;
        res = 0;
        cin >> m >> n >> x >> y;
        dfs(x, y, 1);
        cout << res << endl;
    }

    return 0;
}
```



##### 2、单词接龙

【[AcWing 1117](https://www.acwing.com/solution/AcWing/content/6796/)】单词接龙是一个与我们经常玩的成语接龙相类似的游戏。现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”，每个单词最多被使用两次。在两个单词相连时，其重合部分合为一部分，例如 beast 和 astonish ，如果接成一条龙则变为 beastonish。我们可以任意选择重合部分的长度，但其长度必须大于等于1，且严格小于两个串的长度，例如 at 和 atide 间不能相连。

> 输入格式
> 输入的第一行为一个单独的整数 n 表示单词数，以下 n 行每行有一个单词（只含有大写或小写字母，长度不超过20），输入的最后一行为一个单个字符，表示“龙”开头的字母。
>
> 你可以假定以此字母开头的“龙”一定存在。

> 输出格式
> 只需输出以此字母开头的最长的“龙”的长度。

> 数据范围
> n≤20

```
输入样例：
5
at
touch
cheat
choose
tact
a

输出样例：
23
提示
连成的“龙”为 atoucheatactactouchoose。
```



**题解**：

```C++
#include <iostream>
#include <string>
#include <algorithm>
#include <vector>
#include <cstring>

using namespace std;

const int N = 25;

vector<int> ver[N],edge[N];//匹配的单词编号和匹配长度

string word[N];

int n,res;

int st[N];

void dfs(string u,int k)
{
    st[k] ++;
    res = max(res,(int)u.size());

    for(int i=0;i<ver[k].size();i++)
    {
        int p=ver[k][i],d=edge[k][i];
        if(st[p]<2)
            dfs(u+word[p].substr(d),p);
    }
    st[k] --; // 恢复现场
}

int main() {
    cin >> n;

    for(int i=1;i<=n;i++)
        cin >> word[i];

    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
        {
            string a = word[i] , b = word[j];
            int len = min(a.size(),b.size());
            for(int k=1;k<len;k++)
            {
                if(a.substr(a.size()-k)==b.substr(0,k))
                {
                    ver[i].push_back(j);
                    edge[i].push_back(k);
                    break;
                }
            }
        }

    string s;

    cin >> s;

    for(int i=1;i<=n;i++)
        if(s[0]==word[i][0])
            dfs(word[i],i);

    cout << res << endl;

    return 0;
}
```



##### 3、分成互质组



#### 3. DFS剪枝与优化

1. 优化搜索顺序

   优先搜索分支较少的节点

2. 排除等效冗余

3. 可行性剪枝

4. 最优性剪枝

------

##### 1、全排列

【[AcWing 823](https://www.acwing.com/problem/content/825/) / [力扣](https://leetcode-cn.com/problems/permutations/)】

**题解**：每个数仅能使用一次，因而需要备忘录。

```C++
#include <iostream>
using namespace std;

const int N = 10;
int n;
int path[N]; // 记录路径
bool st[N]; // 标记某层是否遍历过

void dfs(int u) {
    if(u == n) { // 遍历完所有层
        for(int i = 0; i < n; i++)
            cout << path[i] << " ";
        cout << endl;
        return;
    }
    for(int i = 1; i <= n; i++) { // 枚举当前位置可以使用的数，每个可使用的数会形成一条分支
        if(!st[i]){ // 找到一个当前层没有用过的数
            path[u] = i;
            st[i] = true; // 此数已使用
            dfs(u + 1); // 搜索下一层
            st[i] = false; // 恢复现场，接下来将遍历另一条路径，此数可重新使用，回溯
        }
    }
}

int main () {
    cin >> n;
    dfs(0); // 从第0层开始搜索
    return 0;
}
```



##### 2、N-皇后

【[Acwing](https://www.acwing.com/problem/content/description/845/) / [力扣](https://leetcode-cn.com/problems/n-queens/)】如何将 *n* 个皇后放置在 *n*×*n* 的棋盘上，并且使皇后彼此之间不能相互攻击。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/8-queens.png)

方法1：可以分析出每行只能放一个皇后，因而可以枚举每一行的皇后放在哪个位置

```C++
#include <iostream>
using namespace std;

const int N = 10;
int n;
bool col[N], dg[N], udg[N]; // 记录选过的列，对角线，反对角线
char g[N][N];

void dfs(int u) {
    if(u == n) { // 遍历完所有行，即安排完所有皇后
        for(int i = 0; i < n; i++)
            cout << g[i] << endl;
        cout << endl;
        return;
    }
    for(int i = 0; i < n; i++) { // 枚举每行可以选择的位置
        if(!col[i] && !dg[i + u] && !udg[n - u + i]) { // 找到一个所在列未选择，正反对角线未选择的位置
            g[u][i] = 'Q';
            col[i] = dg[i + u] = udg[n - u + i] = true;
            dfs(u + 1); // 遍历下一行
            // 恢复现场
            col[i] = dg[i + u] = udg[n - u + i] = false;
            g[u][i] = '.';
        }
    }
}

int main () {
    cin >> n;
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++)
            g[i][j] = '.';
    }
    dfs(0); // 从第0行开始搜索，即安排第1个皇后的位置
    return 0;
}
```

方法2：更加直接的方法，枚举每个格子，可能放皇后也可能不放皇后，复杂度高很多

```C++
#include <iostream>

using namespace std;


const int N = 20;
int n;
bool row[N], col[N], dg[N], udg[N]; // 记录选过的行，列，对角线，反对角线
char g[N][N];

// 行、列、当前已放置皇后数
void dfs(int x, int y, int s) {
    if(y == n) y = 0, x++; // 处理超过边界的情况
    
    if(x == n) { // 遍历完所有行，枚举完n^2个位置
        if(s == n) { // 已放置n个皇后，打印
            for(int i = 0; i < n; i++)
                cout << g[i] << endl;
            cout << endl;
        }
        return; // 枚举完所有位置，返回
    }
    
    // 不放皇后，搜下一个位置
    dfs(x, y + 1, s);
    
    // 放皇后
    if(!row[x] && !col[y] && !dg[x + y] && !udg[x - y + n]) { // 所在行列及正反对角线无皇后
        g[x][y] = 'Q';
        row[x] = col[y] = dg[x + y] = udg[x - y + n] = true;
        dfs(x, y + 1, s + 1); // 搜下一个位置，已放皇后数加1
        // 恢复现场
        row[x] = col[y] = dg[x + y] = udg[x - y + n] = false;
        g[x][y] = '.';
    }
}

int main () {
    cin >> n;
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++)
            g[i][j] = '.';
    }
    dfs(0, 0, 0); // 从第0行0列开始搜索
    return 0;
}
```



##### 3、小猫爬山

【[AcWing 165](https://www.acwing.com/problem/content/167/)】翰翰和达达饲养了N只小猫，这天，小猫们要去爬山。经历了千辛万苦，小猫们终于爬上了山顶，但是疲倦的它们再也不想徒步走下山了（呜咕>_<）。翰翰和达达只好花钱让它们坐索道下山。索道上的缆车最大承重量为W，而N只小猫的重量分别是C1、C2……CN。当然，每辆缆车上的小猫的重量之和不能超过W。每租用一辆缆车，翰翰和达达就要付1美元，所以他们想知道，最少需要付多少美元才能把这N只小猫都运送下山？

> 输入格式
> 第1行：包含两个用空格隔开的整数，N和W。
> 第2..N+1行：每行一个整数，其中第i+1行的整数表示第i只小猫的重量Ci。
>
> 输出格式
> 输出一个整数，表示最少需要多少美元，也就是最少需要多少辆缆车。
> 数据范围
> 1≤N≤18,
> 1≤Ci≤W≤108

```
输入样例：
5 1996
1
2
1994
12
29

输出样例：
2
```

**题解**：此题使用dfs进行暴力搜索，每次安排一只猫，有两种情况：1、放到现有的缆车上  2、新加一辆缆车，放到新的缆车上。

需要注意的地方：此题中**不需要设置备忘录**，每次安排一只猫，每只猫均有可能放到任意一辆缆车上，即**缆车可以重复使用**

使用到的剪枝优化方法：

- 优化搜索顺序，先安排重量大的猫，可以减少需要判断的次数。比如一只猫比缆车承重量还大，那么直接不需要安排了
- 最优性剪枝，如果当前分支使用的缆车数量比之前方案使用的缆车数量还多，那么无需继续进行搜索
- 可行性剪枝，即跳过某猫加入缆车后超重的情况

```C++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 20;

int n, m; // 猫数量，缆车承重量
int sum[N], cat[N]; // 各缆车中猫的总重量，各猫的重量
int ans = N;

void dfs(int u, int k)
{
    // @最优性剪枝
    if (k >= ans) return; // 此方案不可能是最小的

    if (u == n) { // 分配完所有猫
        ans = k; // 已剪枝，此时k一定小于ans
        return;
    }

    // 在当前车中选一辆
    for (int i = 0; i < k; i ++ ) // 安排当前这只小猫可能放到哪辆车上
        if (sum[i] + cat[u] <= m) { // @可行性剪枝
            sum[i] += cat[u]; // 第u只小猫放到第i辆车上
            dfs(u + 1, k); // 安排下一只小猫，车数量不变
            sum[i] -= cat[u]; // 恢复现场
        }

    // 新开一辆车
    sum[k] = cat[u]; // 第u只小猫放到新开的第k辆车上
    dfs(u + 1, k + 1); // 安排下一只小猫，车数量加1
    sum[k] = 0; // 恢复现场
}

int main()
{
    cin >> n >> m;
    for (int i = 0; i < n; i ++ ) cin >> cat[i];

    // @优化搜索顺序
    sort(cat, cat + n);
    reverse(cat, cat + n); // 按重量从大到小排序，先安排重量大的猫

    dfs(0, 0); // 从第1只猫(0号)，0辆车开始安排

    cout << ans << endl;

    return 0;
}
```



##### 4、数独

##### 5、木棒

##### 6、生日蛋糕



#### 4. 迭代加深

##### 1、加成序列



#### 5. 双向DFS

##### 1、送礼物



#### 6. IDA*

##### 1、排书

##### 2、回转游戏



## 4、数学知识

### 质数

定义：在大于1的整数中，如果只包含1和本身这两个约数，这个数就被称为质数或素数。0~N中质数个数<N。

#### 1、质数的判定—试除法★

原理：若n % d == 0，即n能被d整除，那么n也能被n/d整除。例如12能被3整除，所以12能被12/3=4整除。那么枚举n的约数时可以只枚举较小的那个约数，即给d添加约数条件**d <= (n/d)**，那么d^2^ <= n, d <= sqrt(n)，因此d只需要从2枚举到sqrt(n)，最终时间复杂度可从O(n)降到**O(sqrt(n))**。

```C++
bool is_prime(int x)
{
    if (x < 2) return false;
    for (int i = 2; i <= x / i; i ++ ) // 普通做法是枚举到n
        if (x % i == 0)
            return false;
    return true;
}
```



#### 2、分解质因数—试除法

**每一个数都可以分解成质数的乘积**，例如 84 = 2<sup>2</sup> \* 3<sup>1</sup> \* 5<sup>0</sup> \* 7<sup>1</sup> \* 11<sup>0</sup> \* 13<sup>0</sup> \* 17<sup>0</sup> \* …

每个合数都可以写成几个[质数](https://baike.baidu.com/item/质数/263515)相乘的形式，其中每个质数都是这个[合数](https://baike.baidu.com/item/合数/49186)的因数，把一个合数用质因数相乘的形式表示出来，叫做**分解质因数**。分解质因数只针对合数。

原理：从2~n枚举所有质因数，因为n中最多只包含一个大于sqrt(n)的质因子，所以 i 枚举到sqrt(n)即可，从而算法时间复杂度从O(n)降到**O(sqrt(n))**。

```C++
// 直接打印质因数及其指数
void divide(int n)
{
    for (int i = 2; i <= n / i; i++) // 枚举所有小于sqrt(n)的数，寻找质因子
        if (n % i == 0) // i一定是质数
        {
            int s = 0;
            while (n % i == 0) n /= i, s++;
            printf("%d %d\n", i, s); // i为一个质数，s为指数
        }
    
    if (n > 1) printf("%d %d\n", n, 1); // n > 1，这个就是唯一一个大于sqrt(n)的质因子
}

// 使用哈希表保存质因数及其指数
void divide(int n)
{
    unordered_map<int,int> primes; // 哈希表用于存储质因数和其指数
    for (int i = 2; i <= n / i; i++) // 枚举所有小于sqrt(n)的数，寻找质因子
        if (n % i == 0) // i一定是质数
        {
            int s = 0;
            while (n % i == 0) n /= i, primes[i]++; // 键为质因数，值为指数
        }
    
    if (n > 1) primes[n]++; // n > 1，这个就是唯一一个大于sqrt(n)的质因子
}
```

```
输入：
84
输出：
2 2
3 1
7 1
```

即 84 = 2^2^ * 3^1^ * 7^1^



#### 3、求素数—朴素筛法★

也叫埃氏筛法，时间复杂度$O(nloglogn)$。也可用于快速求0~n中的素数个数$(<=n-1)$

注意：以下模板求的是[0,n]的素数，**包括n**在内

```C++
int primes[N], cnt; // primes[]存储所有素数
bool st[N];         // st[x]存储x是否被筛掉

// 求[0,n]的所有素数及素数个数，包括n
void get_primes(int n)
{
    for (int i = 2; i <= n; i++) { // 若求[0,n)中素数个数，去掉等号
        if (st[i]) continue;
        primes[cnt++] = i;
        for (int j = i + i; j <= n; j += i) // 筛掉倍数，若求[0,n)中素数个数，去掉等号
            st[j] = true;
    }
}
```



#### 4、求素数—线性筛法

n只会被其最小质因子筛掉

- i % p[j] == 0
  - p[j] 一定是 i 的最小质因子，p[j] 一定是 p[j] * i 的最小质因子
- i % p[j] != 0
  - p[j] 一定小于 i 的所有质因子

注意：以下模板求的是[0,n]的素数，**包括n**在内

```C++
int primes[N], cnt; // primes[]存储所有素数，cnt为0~n中素数个数
bool st[N];         // st[x]存储x是否被筛掉

// 求[0,n]的所有素数及素数个数，包括n
void get_primes(int n)
{
    for (int i = 2; i <= n; i++) // 若求[0,n)中素数个数，去掉等号
    {
        if (!st[i]) primes[cnt++] = i;
        for (int j = 0; primes[j] <= n / i; j++) // 求[0,n)中素数个数，也不要去掉等号
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break; // primes[j]一定是i的最小质因子
        }
    }
}
```



### 约数

#### 1、求约数—试除法

求一个数的所有约数，时间复杂度$O(\sqrt{n})$

```C++
vector<int> get_divisors(int n)
{
    vector<int> res;
    for (int i = 1; i <= n / i; i++)
        if (n % i == 0) {
            res.push_back(i);
            if (i != n / i) res.push_back(n / i); // i 与 n/i 仅取一个
        }
    sort(res.begin(), res.end());
    return res;
}
```



#### 2、约数个数/约数之和

如果 N = p1^c1^ * p2^c2^ * ... *pk^ck^，即分解质因数
**约数个数公式**： (c1 + 1) * (c2 + 1) * ... * (ck + 1)

```C++
// 约数个数代码实现
long long res = 1;
for(auto prime : primes) res = res*(prime.second + 1);
```

**约数之和公式**： (p1^0^ + p1^1^ + ... + p1^c1^) * ... * (pk^0^ + pk^1^ + ... + pk^ck^)  —— pk为一个质因数，ck为其指数

求pk^0^ + pk^1^ + ... + pk^ck^ 可以使用while循环实现：`while(ck--) t = (t * p + 1);`

- t=1时，t = t * p + 1 = p + 1，t = p + 1
- t = p + 1时，t = t * p + 1 = (p + 1) * p + 1 = p^2^+ p + 1
- ...
- t = p^ck^ + ... + p^1^ + p^0^

```C++
// 约数之和代码实现
LL res = 1;
for(auto prime : primes) {
    int p = prime.first, a = prime.second; // p为质因数的底数，a为其指数
    LL t = 1; // p对应的总和pk^0 + pk^1 + ... + pk^ck
    while(a--) t = (t * p + 1); // 求pk^0 + pk^1 + ... + pk^ck
    res = res * t;
}
```



#### 3、最大公约数—欧几里得算法

也叫辗转相除法，时间复杂度$O(logn)$

公式：$(a, b) = (b, {a}\ \%\ {b})$，意思就是a和b的最大公约数等于b和a模b的最大公约数

b = 0 时 (a, 0) 的最大公约数为a，0可以整除任何数

```C++
int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}
```

#### ————————

#### 1. 约数个数

给定n个正整数ai，输出这些数的乘积的约数个数，结果对1e9 + 7取模

输入：第一行为整数n，接下来n行每行包含一个整数ai

```
输入：
3
2
6
8
输出：
12
```

**题解**：对每个整数ai分解质因数，然后累加所有质因子的指数。可使用哈希表的键存储所有质因子，值为个质因子的指数的和。

```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL; 
const int mod = 1e9 + 7;
int main(){
    int n,x;
    unordered_map<int,int> primes; // first存储质因数，second存储指数
    cin >> n;
    while(n--){
        cin >> x;
        for(int i = 2;i <= x/i; ++i){ // 对每个整数分解质因数
            while(x % i == 0){
                x /= i;
                primes[i]++; // 质数i的指数加1
            }
        }
        if(x > 1) primes[x]++; // 处理较大的质因子
    }
    
    LL res = 1;
    for(auto prime : primes) res = res*(prime.second + 1) % mod; // 求约数个数公式
    cout << res;
    return 0;
}
```



#### 2. 约数之和

给定n个正整数ai，输出这些数的乘积的约数之和，结果对1e9 + 7取模

输入：第一行为整数n，接下来n行每行包含一个整数ai

```
输入：
3
2
6
8
输出：
12
```

**题解**：

```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL; 
const int mod = 1e9 + 7;
int main(){
    int n,x;
    unordered_map<int,int> primes; // first存储质因数，second存储指数
    cin >> n;
    while(n--){
        cin >> x;
        for(int i = 2;i <= x/i; ++i){ // 对每个整数分解质因数
            while(x % i == 0){
                x /= i;
                primes[i]++; // 质数i的指数加1
            }
        }
        if(x > 1) primes[x]++; // 处理较大的质因子
    }
    
    LL res = 1;
    for(auto prime : primes) {
        int p = prime.first, a = prime.second; // p为质因数的底数，a为其指数
        LL t = 1; // p对应的总和pk^0 + pk^1 + ... + pk^ck
        while(a--) t = (t * p + 1) % mod; // 求pk^0 + pk^1 + ... + pk^ck
        res = res * t % mod;
    }
    cout << res;
    return 0;
}
```



#### 3. 最大公约数

【[AcWing](https://www.acwing.com/solution/AcWing/content/7657/)】给定n对正整数$a_i,b_i$,请你求出每对数的最大公约数

```
输入
2
3 6
4 6
输出
3
2
```

**题解**：

```C++
using namespace std;
int n,a,b;

int gcd(int a,int b){
    return b ? gcd(b , a%b) : a;
} 

int main() {
    scanf("%d",&n);
    while(n--) {
        scanf("%d%d",&a,&b);
        printf("%d\n",gcd(a,b));
    }
    return 0;
}
```



### 欧拉函数

欧拉函数的定义：**1~N中与N互质的数的个数**，记为$ϕ(N)$

若在算数基本定理中，$N=p1^{a1}×p2^{a2}×……×p2^{a2}$，则：

$ϕ(N)=N(1−\frac{1}{p_1})(1−\frac{1}{p_2})……(1−\frac{1}{p_n})=N(\frac{p_1 - 1}{p_1})(\frac{p_2 - 1}{p_2})……(\frac{p_n - 1}{p_n})$



#### 1、求欧拉函数

```c++
int phi(int x)
{
    int res = x;
    for (int i = 2; i <= x / i; i++)
        if (x % i == 0)
        {
            res = res / i * (i - 1);
            while (x % i == 0) x /= i;
        }
    if (x > 1) res = res / x * (x - 1);

    return res;
}
```



#### 2、筛法求欧拉函数

```C++
int primes[N], cnt; // primes[]存储所有素数
int euler[N];       // 存储每个数的欧拉函数
bool st[N];         // st[x]存储x是否被筛掉

void get_eulers(int n)
{
    euler[1] = 1;
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i])
        {
            primes[cnt ++ ] = i;
            euler[i] = i - 1;
        }
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            int t = primes[j] * i;
            st[t] = true;
            if (i % primes[j] == 0)
            {
                euler[t] = euler[i] * primes[j];
                break;
            }
            euler[t] = euler[i] * (primes[j] - 1);
        }
    }
}
```



### 快速幂

快速求出 ${a}^{k}\ mod\ {p}$ 的结果，时间复杂度$O(logk)$，其中 $1<= a,k,p <= 10^9$

#### 快速幂模板★

```C++
// 求 m^k mod p，时间复杂度 O(logk)。
typedef long long LL;
int qmi(int a, int k, int p)
{
    int res = 1;
    while (k) {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}
```



#### 1. 快速幂

给定 n 组 ${a_i},{b_i},{p_i}$，对于每组数据，求出${a_i}^{b_{i}}\ mod\ {p_i}$ 的值。

> 输入格式
> 第一行包含整数 n 。
> 接下来 n 行，每行包含三个整数 ai,bi,pi 。

> 输出格式
> 对于每组数据，输出一个结果，表示  a~i~^bi^ mod p~i~ 的值。
```
输入样例：
2
3 2 5
4 3 9
输出样例：
4
1
```



**题解**：

```C++
#include <iostream>
using namespace std;

typedef long long LL;
int qmi(int a, int k, int p)
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}

int main(){
    int n;
    scanf("%d", &n);
    while(n--) {
        int a, k, p;
        scanf("%d%d%d", &a, &k, &p);
        printf("%d\n", qmi(a, k, p));
    }
    return 0;
}
```



#### 2. 快速幂求逆元

【[AcWing](https://www.acwing.com/solution/AcWing/content/3054/)】给定n组$a_i, p_i$，其中 $p_i$ 是质数，求 $a_i$ 模 $p_i$ 的乘法逆元，若逆元不存在则输出 impossible。

> 乘法逆元的定义：若整数 $b,m$ 互质（即$gcd(a, b) = 1$），并且 $b|a$，则存在一个整数x，使得$a/ b ≡ a * x(mod\ m)$，则称 $x$ 为 $b$ 的模 $m$ 乘法逆元，记为$b^{-1}(mod\ m)$
>
> $b$ 存在乘法逆元的充分必要条件是 $b$ 与模数 $m$ 互质。当模数 $m$ 为质数时，$b^{m-2}$即为$b$的乘法逆元。

```
输入
3
4 3
8 5
6 3
输出
1
2
impossible
```

**题解**：

因为题目给定的 $p$ 是质数，因此使用可用快速幂 $qmi(a, p - 2, p)$ 求 $a^{p−2}\ \%\ p$。

如果模数$p$不是质数，就需要使用扩展欧几里得算法求解同余方程：$ax≡1$($mod$ $p$)，$x$即为$a^{-1}$
转化：$ax+py=1$，由 $a,p$ 互质可知 $gcd(a,b)=1$  `exgcd(a, p, x, y); x = (x % p + p) % p;` 即可求得0~$p-1$内的逆元

```C++
#include <iostream>
using namespace std;
typedef long long LL;

LL qmi(int a, int b, int p)
{
    LL res = 1;
    while(b){
        if(b & 1) res = res * a % p;
        a = (LL)a * a % p;
        b >>= 1;
    }
    return res;
}

int main()
{
    int n; cin >> n;
    while(n --){
        int a, p;
        cin >> a >> p;
        if(a % p == 0) puts("impossible");
        else cout << qmi(a, p - 2, p) << endl;
    }
    return 0;
}
```



### 扩展欧几里得算法

算法功能：求$x, y$，使得 $ax + by = gcd(a, b)$

```C++
// 求x, y，使得ax + by = gcd(a, b)
int exgcd(int a, int b, int &x, int &y) // 返回gcd(a,b)，并求出解(引用带回)
{
    if (!b) // b==0
    {
        x = 1; y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= (a/b) * x;
    return d;
}
```



#### 1. 扩展欧几里得算法

【[AcWing](https://www.acwing.com/solution/AcWing/content/1393/)】给定$n$对正整数$a_{i},b_{i}$，对于每对数，求出一组$x_{i},y_{i}$，使其满足$a_{i}x_{i}+b_{i}y_{i}=gcd(a_{i},b_{i})$。

> 输入格式
> 第一行包含整数$n$。
> 接下来$n$行，每行包含两个整数$a_{i},b_{i}$。
>
> 输出格式
> 输出共$n$行，对于每组$a_{i},b_{i}$，求出一组满足条件的$x_{i},y_{i}$，每组结果占一行。
> 本题答案不唯一，输出任意满足条件的$x_{i},y_{i}$均可。
>
> 数据范围
> $1≤n≤10^{5},$
> $1≤ai,bi≤2∗10^{9}$

```
输入样例
2
4 6
8 18
输出样例
-1 1
-2 1
```

**题解**：

```C++
#include<bits/stdc++.h>
using namespace std;

int exgcd(int a, int b, int &x, int &y) // 返回gcd(a,b)，并求出解(引用带回)
{
    if (!b) {
        x = 1; y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= (a/b) * x;
    return d;
}

int main(){
    int n,a,b,x,y;
    cin >> n;
    while(n--){
        cin >> a >> b;
        exgcd(a,b,x,y);
        cout << x << " " << y << endl;
    }
    return 0;
}
```



#### 2. 线性同余方程

给定n组数据${a_i},{b_i},{m_i}$  对于每组数求出一个$x_i$，使其满足$a_ix_i ≡ b_i (mod\ m_i)$，如果无解则输出impossible

第一行包含整数n,接下来n行，每行一组数据${a_i},{b_i},{m_i}$

```
输入：
2
2 3 6
4 3 5
输出：
impossible
-3
```

**题解**：

$a_ix_i ≡ b_i (mod\ m_i)$ 即 $a_i * x_i$的结果除以$m_i$余$b_i$，$ax ≡ b (mod\ m)$ 等价于求$ax = m*(-y) + b$ 即 $ax + my = b$，此方程有解当且仅当 b 能够被 a 与 n 的最大公约数整除（记作 gcd(a,n) | b），如果 $x_0$ 是方程的一个解，那么所有的解可以表示为$x_0 + k \frac {n}{d}\ |\ k \in Z$ 

> [线性同余方程 - 维基百科](https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B)

```C++
#include<bits/stdc++.h>
using namespace std;
int n, x, y;
using LL = long long ;

int exgcd(int a, int b, int &x, int &y) // 返回gcd(a,b)，并求出解(引用带回)
{
    if (!b) {
        x = 1; y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= (a/b) * x;
    return d;
}

int main() {
    cin >> n;
    while (n --) {
        int a, b, m;
        cin >> a >> b >> m;
        int d = exgcd(a, m, x, y);
        if (b % d) puts("impossible");
        else {
            x = (LL)x * b / d % m;
            cout << x << endl;
        }
    }
    return 0;
}
```



### 中国剩余定理

#### 1. 表达整数的奇怪方式

【[AcWing](https://www.acwing.com/problem/content/206/)】

给定 $2n$ 个整数$a_1,a_2,...,a_n$和$m_1,m_2,...,m_n$,求一个最小的非负整数 $x$，满足$ \forall i \in [1,n],x \equiv m_i(mod\ a_i)$。

**[题解](https://www.acwing.com/solution/AcWing/content/3539/)**



### 高斯消元

```c++
// a[N][N]是增广矩阵
int gauss()
{
    int c, r;
    for (c = 0, r = 0; c < n; c ++ )
    {
        int t = r;
        for (int i = r; i < n; i ++ )   // 找到绝对值最大的行
            if (fabs(a[i][c]) > fabs(a[t][c]))
                t = i;

        if (fabs(a[t][c]) < eps) continue;

        for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]); // 将绝对值最大的行换到最顶端
        for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c]; // 将当前上的首位变成1
        for (int i = r + 1; i < n; i ++ ) // 用当前行将下面所有的列消成0
            if (fabs(a[i][c]) > eps)
                for (int j = n; j >= c; j -- )
                    a[i][j] -= a[r][j] * a[i][c];

        r ++ ;
    }

    if (r < n)
    {
        for (int i = r; i < n; i ++ )
            if (fabs(a[i][n]) > eps)
                return 2; // 无解
        return 1; // 有无穷多组解
    }

    for (int i = n - 1; i >= 0; i -- )
        for (int j = i + 1; j < n; j ++ )
            a[i][n] -= a[i][j] * a[j][n];

    return 0; // 有唯一解
}
```



### 求组合数

组合常规公式：$C_{a}^{b}= \frac {a!}{b!(a-b)!}$

组合递推公式：$C_{a}^{b}=C_{a-1}^{b-1}+C_{a-1}^{b}$



#### 1、求组合数—递归法★

利用递推公式 $C_{a}^{b}=C_{a-1}^{b-1}+C_{a-1}^{b}$，递归边界为$C_{a_i}^{0}=1$

```C++
// c[a][b] 表示从a个苹果中选b个的方案数
for (int i = 0; i < N; i ++ )
    for (int j = 0; j <= i; j ++ )
        if (!j) c[i][j] = 1; // j == 0，c[i][j] = 1
        else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
```



#### 2、求组合数—预处理逆元★

公式 $C_{a}^{b}= \frac {a!}{b!(a-b)!}$ 中有三个数的阶乘，但阶乘的除法不成立，因而使用预处理逆元的方式将除法转换为乘法。

公式转换为 $C_{a}^{b} =  \frac {a!}{b!(a-b)!} = fact[a] \times infact[a - b] \times infact[b]$，其中 $fact[i]  = i!$ 表示 $i$ 的阶乘，$infact[i]  = (i!)^{-1}$，表示 $i$ 的阶乘的逆元

```C++
// 首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N]
// 如果取模的数是质数，可以用费马小定理求逆元
int qmi(int a, int k, int p) // 快速幂模板
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}

// 预处理阶乘的余数和阶乘逆元的余数
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
    fact[i] = (LL)fact[i - 1] * i % mod;
    infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}

// 计算组合结果
res = (LL)fact[a] * infact[b] % mod * infact[a - b] % mod;
```



#### 3、求组合数—Lucas定理

卢卡斯定理：$C_{a}^{b}≡C_{a\ mod\ p}^{b\ mod\ p} * C_{a/p}^{b/p}\ (mod\ p)$

```C++
// Lucas定理：若p是质数，则对于任意整数 1 <= m <= n，有：
// C(n, m) = C(n % p, m % p) * C(n / p, m / p) (mod p)

int qmi(int a, int k) // 快速幂模板
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}


int C(int a, int b) // 通过定理求组合数C(a, b)
{
    int res = 1;
    for (int i = 1, j = a; i <= b; i ++, j -- )
    {
        res = (LL)res * j % p;
        res = (LL)res * qmi(i, p - 2) % p;
    }
    return res;
}


int lucas(LL a, LL b)
{
    if (a < p && b < p) return C(a, b);
    return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```



#### 4、求组合数—分解质因数法

```C++
// 当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：
//     1. 筛法求出范围内的所有质数
//     2. 通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。
//     	n! 中p的次数是 n / p + n / p^2 + n / p^3 + ...
//     3. 用高精度乘法将所有质因子相乘

int primes[N], cnt;     // 存储所有质数
int sum[N];     // 存储每个质数的次数
bool st[N];     // 存储每个数是否已被筛掉


void get_primes(int n)      // 线性筛法求素数
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}


int get(int n, int p)       // 求n！中的次数
{
    int res = 0;
    while (n)
    {
        res += n / p;
        n /= p;
    }
    return res;
}


vector<int> mul(vector<int> a, int b)       // 高精度乘低精度模板
{
    vector<int> c;
    int t = 0;
    for (int i = 0; i < a.size(); i ++ )
    {
        t += a[i] * b;
        c.push_back(t % 10);
        t /= 10;
    }

    while (t)
    {
        c.push_back(t % 10);
        t /= 10;
    }

    return c;
}

get_primes(a);  // 预处理范围内的所有质数

for (int i = 0; i < cnt; i ++ )     // 求每个质因数的次数
{
    int p = primes[i];
    sum[i] = get(a, p) - get(b, p) - get(a - b, p);
}

vector<int> res;
res.push_back(1);

for (int i = 0; i < cnt; i ++ )     // 用高精度乘法将所有质因子相乘
    for (int j = 0; j < sum[i]; j ++ )
        res = mul(res, primes[i]);
```



#### 5、卡特兰数

给定n个0和n个1，它们按照某种顺序排成长度为2n的序列，满足任意前缀中0的个数都不少于1的个数的序列的数量为：$Cat(n) = C_{2n}^n - C_{2n}^{n-1} = \frac {C_{2n}^n}{ n + 1}$



#### ————————

#### 1. 求组合数 I

给定 $n$ 组询问，每组询问给定两个整数 $a, b$ 请你求出$C_{a}^{b}\ mod\ (10^7 + 7)$的值。数据范围$1\leq n \leq 10000$，$1\leq b \leq a \leq 10000$

```
输入，第一行为个数n
3
3 1
5 3
2 2
输出
3
10
1
```

**题解**：递归法

```C++
#include <iostream>
using namespace std;

const int N = 2010, mod = 1e9 + 7;
int c[N][N];

void init() {
    for(int i = 0; i < N; i++) {
        for(int j = 0; j <= i; j++) {
            if(!j) c[i][j] = 1; // j == 0，c[i][j] = 1
            else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
        }
    }
}

int main() {
    init();

    int n;
    cin >> n;
    while(n--) {
        int a, b;
        cin >> a >> b;

        cout << c[a][b] << endl;
    }
    return 0;
}
```



#### 2. 求组合数 II

给定 $n$ 组询问，每组询问给定两个整数 $a, b$ 请你求出$C_{a}^{b}\ mod\ (10^7 + 7)$的值。数据范围$1\leq n \leq 10000$，$1\leq b \leq a \leq 10^5$

```
输入，第一行为个数n
3
3 1
5 3
2 2
输出
3
10
1
```

**题解**：预处理逆元

```C++
#include<iostream>
using namespace std;

typedef long long LL;
const int N = 100010, mod = 1e9 + 7;

LL fact[N], infact[N]; // infact[N]指逆元，因为mod为素数，所以可以用费马小定理来求

//qmi是快速幂
int qmi(int a, int k, int p)
{
    int res = 1;
    while(k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}

int main()
{
    fact[0] = infact[0] = 1;
    for(int i = 1; i < N; i ++)
    {
        fact[i] = (LL)fact[i - 1] * i % mod;
        infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod; //要取模
    }

    int n;
    cin >> n;
    while(n --)
    {
        int a, b;
        scanf("%d%d", &a, &b);
        int res;
        res = (LL)fact[a] * infact[b] % mod * infact[a - b] % mod; // 前两个相乘之后就要取模
        printf("%d\n", res);
    }
    return 0;
}
```



#### 3. 求组合数 III

给定 $n$ 组询问，每组询问给定两个整数 $a, b, p$ 请你求出$C_{a}^{b}\ mod\ p$ 的值。数据范围$1\leq n \leq 20$，$1\leq b \leq a \leq 10^{18}$，$1\leq p \leq 10^{5}$

```
输入，第一行为个数n
3
5 3 7
3 1 5
6 4 13
输出
3
3
2
```

**题解**：

```C++
#include<iostream>
using namespace std;

typedef long long LL;

int p;

int qmi(int a, int k) // 快速幂模板
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}


int C(int a, int b) // 通过定理求组合数C(a, b)
{
    int res = 1;
    for (int i = 1, j = a; i <= b; i ++, j -- )
    {
        res = (LL)res * j % p;
        res = (LL)res * qmi(i, p - 2) % p;
    }
    return res;
}


int lucas(LL a, LL b)
{
    if (a < p && b < p) return C(a, b);
    return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}

int main() {
    int n; cin >> n;
    while(n--) {
        LL a, b;
        cin >> a >> b >> p;
        cout << lucas(a, b) << endl;
    }
    return 0;
}
```



#### 4. 求组合数 IV

输入$a,b$，求$C_a^b$的值。数据范围 $1\leq b \leq a \leq 5000$

注意结果可能很大，需要使用高精度计算。

> 输入格式
> 共一行，包含两个整数 $a$ 和 $b$。

> 输出格式
> 共一行，输出$C_a^b$的值。

**题解**：

```C++
#include<iostream>
#include<vector>
using namespace std;

const int N = 5010;
int primes[N], cnt;
int sum[N];
bool st[N];

//线性筛素数
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++)
    {
        if (!st[i]) primes[cnt ++] = i;
        for(int j = 0; primes[j] <= n / i; j ++)
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}

//得到n！中p的次数
int get(int n, int p)
{
    int res = 0;
    while(n)
    {
        res += n / p;
        n /= p;//n每次除以p;
    }
    return res;
}

//高精度乘法
vector<int> mul(vector<int> a, int b)
{
    vector<int> c;
    int t = 0;
    for(int i = 0; i < a.size(); i ++)
    {
        t += a[i] * b;
        c.push_back(t % 10);
        t /= 10;
    }
    while(t)
    {
        c.push_back(t % 10);
        t /= 10;
    }
    return c;
}


int main()
{
    int a, b;
    cin >> a >> b;

    get_primes(a);

    for (int i = 0; i < cnt; i ++)
    {
        int p = primes[i];
        sum[i] = get(a, p) - get(b, p) - get(a - b, p); // 得到C[a][b]中p的次数，因为是幂的形式，所以是减
    }

    vector<int> res;
    res.push_back(1); //要先放进去一个1
    for(int i = 0; i < cnt; i ++)
        for(int j = 0; j < sum[i]; j ++)
            res = mul(res, primes[i]);

    for(int i = res.size() - 1; i >= 0; i --) printf("%d", res[i]);
    return 0;
}
```



#### 5. 满足条件的01序列

给定n个0和n个1，它们将按照某种顺序排成长度为2n的序列，求它们能排列成的所有序列中，能够满足任意前缀序列中0的个数都不少于1的个数的序列有多少个。

输出的答案对10^9^ + 7取模。数据范围1≤n≤10^5^

> 输出格式
> 共一行，包含整数n。

> 输出格式
> 共一行，包含一个整数，表示答案。

```
输入
3
输出
5
```

**题解**：

```C++
#include<iostream>

using namespace std;

typedef long long LL;
const int mod = 1e9 + 7;

// 快速幂
int qmi(int a, int k)
{
    int res = 1;
    while(k)
    {
        if (k & 1) res = (LL)res * a % mod;
        a = (LL) a * a % mod;
        k >>= 1;
    }
    return res;
}

int main()
{
    int n;
    cin >> n;
    int a = 2 * n, b = n;
    int res = 1;
    for(int i = a, j = 1; j <= b; j ++, i --)
    {
        res = (LL)res * i % mod;
        res = (LL)res * qmi(j, mod - 2) % mod;
    }
    res = (LL) res * qmi(n + 1, mod - 2) % mod;
    cout << res;
    return 0;
}
```



### 容斥原理

### 简单博弈论



## 5、动态规划

1. **状态表示**——如何表示每个状态；例如，背包问题状态表示为二维：`f(i, j)`

   所有状态即**所有满足条件的选法的集合**

   - 集合——所有选法
     - 条件：1、只从前 i 个物品中选   2、选出物品的总体积 <= j
   - 属性——集合的属性；例如最大值、最小值、数量

2. **状态计算**——如何计算每个状态；例如，如何计算每个`f(i, j)`

   如何将当前的集合划分为若干个子集，使得每个子集可以用更小的状态表示出来——集合划分

   集合划分的原则：1、不重（非必须）    2、不漏

   01背包问题中，状态`f(i, j)`可划分为两个子集：{ 不含 i ，含 i }，即`f(i - 1 , j)`和`f(i - 1 , j - vi) + wi`

------



### 背包问题

资料：[背包九讲](https://blog.csdn.net/stack_queue/article/details/53544109)

- 01背包：每件物品最多用一次
- 完全背包：每件物品有无限个
- 多重背包：每个物品最多有S~i~个
- 分组背包：N组物品，每组最多选一个物品

------

#### 1. 01背包问题

【[AcWing 2](https://www.acwing.com/problem/content/2/)】有 N 件物品和一个容量是 W 的背包。**每件物品只能使用一次**。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。

**题解**：状态转移方程：`f[i][j] = max(f[i - 1][j - w[i]] + v[i], f[i - 1][j])`

**方法1：二维动规**

非class写法需要注意的细节：

- 读入物品体积和价值时，从1开始读入
- 枚举物品体积和价值时，从1开始枚举
- 0号物品的体积和价值默认为0，刚好作为初始条件
- 这里的dp数组`f[N][N]`初始化了足够的空间，实际使用到`f[m+1][n+1]`，即`[0-m]`个物品`[0-n]`种重量。

```C++
#include <iostream>
#include <cstring>
using namespace std;

const int N = 1010;
int m, n; // 物品数量，背包体积
int w[N], v[N]; // 体积，价值
int f[N][N]; // 全局变量，默认全部初始化为0，实际使用到f[m+1][n+1]

int main() {
    cin >> m >> n;
    for(int i = 1; i <= m; i++) cin >> w[i] >> v[i]; // 注意，小标为1开始存放，第0件物品的重量和价值为0
    
    memset(f, 0, sizeof(f));
    for(int i = 1; i <= m; i++) { // 从1开始枚举物品个数
        for(int j = 1; j <= n; j++) { // 从1开始枚举背包容量
            if(j - w[i] >= 0) // 背包体积大于等于物品体积，装入
                f[i][j] = max(f[i - 1][j - w[i]] + v[i], f[i - 1][j]);
            else f[i][j] = f[i - 1][j]; // 背包体积小于物品体积，不装入
        }
    }
    
    cout << f[m][n];
    
    return 0;
}
```

class写法需要注意的细节：

- dp数组初始化时要多出0号物品的体积和价值，即初始化`N+1`行`W+1`列
- 输入的weights数组和values数组中重量和价值是从下标0开始存放的，即weights[0]存放第1个物品的重量而不是第0件物品的重量。第 i 件物品的重量为`weights[i - 1]`，价值为`values[i - 1]`

```C++
// W 为背包总重量
// N 为物品数量
// weights 数组存储 N 个物品的重量
// values 数组存储 N 个物品的价值
int knapsack(int W, int N, vector<int>& weights, vector<int>& values) {
    vector<vector<int>> dp(N + 1, vector<int>(W + 1, 0));
    for (int i = 1; i <= N; i++) { // 注意从物品数量为1开始枚举到N
        int w = weights[i - 1], v = values[i - 1]; // 第i个物品的重量，价值
        for (int j = 1; j <= W; j++) { // 注意从背包容量为1开始枚举到W
            if (j >= w) { // 第i个物体的重量不大于背包容量j，装入不装入择优
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w] + v);
            } else { // 第i个物体的重量大于背包容量j，毫无疑问，不装入
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
    return dp[N][W];
}
```

**方法2：一维动规**

根据状态转移方程，`f[i][j] = max(f[i - 1][j - w[i]] + v[i], f[i - 1][j])`，计算`f[i][j]`时需要使用**上一行左侧**的数据`f[i - 1][j - w[i]]`，因而**简化为1维时需要从高到低（逆序）枚举背包容量**。

```C++
#include <iostream>
#include <cstring>
using namespace std;

const int N = 1010;
int m, n; // 物品数量，背包体积
int w[N], v[N]; // 体积，价值
int f[N]; // 全局变量，默认全部初始化为0，实际使用到f[m+1][n+1]

int main() {
    cin >> m >> n;
    for(int i = 1; i <= m; i++) cin >> w[i] >> v[i]; // 注意，小标为1开始存放，第0件物品的重量和价值为0
    
    memset(f, 0, sizeof(f));
    for(int i = 1; i <= m; i++) { // 从1开始枚举物品个数
        for(int j = n; j >= 1; j--) { // 从1开始枚举背包容量
            if(j - w[i] >= 0) // 背包体积大于等于物品体积，装入
                f[j] = max(f[j - w[i]] + v[i], f[j]);
        }
    }
    
    cout << f[n];
    
    return 0;
}
```

进一步的，因为要求`j - w[i] >= 0`，所以第二层循环从`w[i]`开始枚举即可，代码简化为

```C++
    for(int i = 1; i <= m; i++) { // 从1开始枚举物品个数
        for(int j = n; j >= w[i]; j--) { // 从w[i]开始枚举背包容量
        	f[j] = max(f[j - w[i]] + v[i], f[j]);
        }
    }
```



#### 2. 完全背包问题

【[AcWing 3](https://www.acwing.com/problem/content/3/)】有 N 种物品和一个容量是 V 的背包，**每种物品都有无限件可用**。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。

**题解**：

状态转移方程1（原始版本）：`f[i][j] = max(f[i - 1][j - k * w[i]] + k * v[i], f[i][j])`，即分为放入k件物品或者不放入k件物品两种情况，**k的限制条件为**`k * w[i] <= j`。

状态转移方程2（根据01背包问题优化）：`f[i][j] = max(f[i][j - w[i]] + v[i], f[i - 1][j])`，与01背包不同的是，不放第 i 个物品时当前状态从当前层转移过来，而不是从上一层转移过来。`f[i][j - w[i]] + v[i]`  VS  `f[i - 1][j - w[i]] + v[i]`

**方法1：原始方法**

根据状态转移方程1，分别枚举物品个数、背包容量、选取的物品件数，注意选取的物品件数从0开始枚举

```C++
#include <iostream>
#include <cstring>
using namespace std;

const int N = 1010;

int m, n;
int v[N], w[N];
int f[N][N];

int main() {
    cin >> m >> n;
    for(int i = 1; i <= m; i++) cin >> w[i] >> v[i];
    
    memset(f, 0, sizeof(f));
    for(int i = 1; i <= m; i++) {
        for(int j = 1; j <= n; j++) {
            for(int k = 0; k * w[i] <= j; k++) // 保证k件物品的重量不超过当前背包容量
                f[i][j] = max(f[i - 1][j - k * w[i]] + k * v[i], f[i][j]);
        }
    }
    
    cout << f[m][n];
    return 0;
}
```

**方法2：二维动规**

根据优化后的状态转移方程2

```C++
#include <iostream>
#include <cstring>
using namespace std;

const int N = 1010;

int m, n;
int v[N], w[N];
int f[N][N];

int main() {
    cin >> m >> n;
    for(int i = 1; i <= m; i++) cin >> w[i] >> v[i];
    
    memset(f, 0, sizeof(f));
    for(int i = 1; i <= m; i++) {
        for(int j = 1; j <= n; j++) {
            if(j - w[i] >= 0)
                f[i][j] = max(f[i][j - w[i]] + v[i], f[i - 1][j]); // 与01背包的不同点
            else f[i][j] = f[i - 1][j];
        }
    }
    
    cout << f[m][n];
    return 0;
}
```

**方法2：一维动规**

根据优化后的状态转移方程2，`f[i][j] = max(f[i][j - w[i]] + v[i], f[i - 1][j])`，计算`f[i][j]`时需要使用**当前行左侧**的数据`f[i][j - w[i]]`，因而**简化为1维时不需要从高到低（逆序）枚举背包容量**。

```C++
#include <iostream>
#include <cstring>
using namespace std;

const int N = 1010;

int m, n;
int v[N], w[N];
int f[N];

int main() {
    cin >> m >> n;
    for(int i = 1; i <= m; i++) cin >> w[i] >> v[i];
    
    memset(f, 0, sizeof(f));
    for(int i = 1; i <= m; i++) {
        for(int j = 1; j <= n; j++) {
            if(j - w[i] >= 0)
                f[j] = max(f[j - w[i]] + v[i], f[j]);
        }
    }
    
    cout << f[n];
    return 0;
}
```

同样，可简化循环

```C++
    for(int i = 1; i <= m; i++) {
        for(int j = w[i]; j <= n; j++) {
            f[j] = max(f[j - w[i]] + v[i], f[j]);
        }
    }
```



#### 3. 多重背包问题

【[AcWing 4](https://www.acwing.com/problem/content/4/)】有 N 种物品和一个容量是 W 的背包。**第 i 种物品最多有 si 件**，每件体积是 wi，价值是 vi。求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。

**题解**：和完全背包问题类似，只是每件物品的件数有固定上限si，而不是无限件。状态转移方程和完全背包问题的原始状态转移方程1一样，`f[i][j] = max(f[i - 1][j - k * w[i]] + k * v[i], f[i][j])`，但是**k的限制条件为**`k <= si`。

```C++
#include <iostream>
#include <cstring>
using namespace std;

const int N = 110;

int m, n;
int w[N], v[N], s[N];
int f[N][N];

int main() {
    cin >> m >> n;
    for(int i = 1; i <= m; i++) cin >> w[i] >> v[i] >> s[i];
    
    memset(f, 0, sizeof(f));
    for(int i = 1; i <= m; i++) {
        for(int j = 1; j <= n; j++) {
            // f[i][j] = f[i][j]; // 不选
            for(int k = 0; k <= s[i]; k++) { // 最多选择s[i]件物品
                if(j >= k * w[i])
                    f[i][j] = max(f[i - 1][j - k * w[i]] + k * v[i], f[i][j]);
            }
        }
    }
    
    cout << f[m][n];
    return 0;
}
```



#### 4. 多重背包问题优化

【[AcWing 5](https://www.acwing.com/problem/content/5/)】



#### 5. 分组背包问题

【[AcWing 9](https://www.acwing.com/problem/content/9/)】有 N 组物品和一个容量是 W 的背包。每组物品有若干个，**同一组内的物品最多只能选一个**。每件物品的体积是 wij，价值是 vij，其中 i 是组号，j 是组内编号。求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。输出最大价值。

**题解**：每组仅能选一个，状态表示：只从第 i 组物品中选，且总体接不大于 j 的所有选法。与01背包不同的是，每个可选的物品为一组物品中的某一个，需要枚举选第 i 组物品的第 k 个物品还是不选。

状态转移方程：`f[i][j] = max(f[i - 1][j - w[i, k]] + v[i, k], f[i - 1][j])`

**方法1：二维动规**

注意1，若不选的话`f[i][j] = f[i - 1][j];`放在第二层循环而不是第三层；注意2：第三层循环中的`f[i][j]`其实就是`f[i - 1][j]`

```C++
#include <iostream>
#include <cstring>
using namespace std;

const int N = 1010;
int m, n;
int w[N][N], v[N][N], s[N];
int f[N][N];

int main() {
    cin >> m >> n;
    for(int i = 1; i <= m; i++) {
        cin >> s[i];
        for(int k = 1; k <= s[i]; k++) {
            cin >> w[i][k] >> v[i][k];
        }
    }
    
    memset(f, 0, sizeof(f));
    for(int i = 1; i <= m; i++) {
        for(int j = 1; j <= n; j++) {
            f[i][j] = f[i - 1][j]; // 不选
            for(int k = 1; k <= s[i]; k++) {
                if(j >= w[i][k])
                    f[i][j] = max(f[i - 1][j - w[i][k]] + v[i][k], f[i][j]); // 注意这里的f[i][j] = f[i - 1][j]
            }
        }
    }
    cout << f[m][n];
    return 0;
}
```

**方法2：一维动规**

当前状态与上一层左侧状态有关，需要逆序枚举背包容量

```C++
#include <iostream>
#include <cstring>
using namespace std;

const int N = 1010;
int m, n;
int w[N][N], v[N][N], s[N];
int f[N];

int main() {
    cin >> m >> n;
    for(int i = 1; i <= m; i++) {
        cin >> s[i];
        for(int k = 1; k <= s[i]; k++) {
            cin >> w[i][k] >> v[i][k];
        }
    }
    
    memset(f, 0, sizeof(f));
    for(int i = 1; i <= m; i++) {
        for(int j = n; j >= 1; j--) {
            for(int k = 1; k <= s[i]; k++) {
                if(j >= w[i][k])
                    f[j] = max(f[j - w[i][k]] + v[i][k], f[j]);
            }
        }
    }
    cout << f[n];
    return 0;
}
```



### 线性DP

#### 1. 数字三角形

【[AcWing 898](https://www.acwing.com/problem/content/900/)】给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。类似题目：[Leetcode 120. 三角形最小路径和](https://leetcode-cn.com/problems/triangle/)

```
        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5
```

**题解**：

- 状态表示——`f(i,j)`：所有从起点走到位置`(i,j)`的路径。

- 状态集合`f(i,j)`分类：
  - (1) 从左上方转移来：`f[i-1][j-1] + a[i][j]` 
  - (2) 从右上方转移来：`f[i-1][j] + a[i][j]`

- 状态转移方程：`f[i][j] = max(f[i-1][j-1] + a[i][j], f[i-1][j] + a[i][j])`

**方法1：从上往下**

需要注意的是，每个位置的最小值与其**左上角和右上角**的最小值有关，因而求左右两侧的点的最小值**会用到三角形之外的点**，因而每行的**左右边界的左右两个位置也需要初始化为负无穷**，因为求边界点的最大值时会与其左上角以及右上角的点进行比较。

二维动规：

```C++
#include <iostream>
#include <cstring>
using namespace std;

const int N = 510, INF = 1e9;
int n;
int a[N][N];
int f[N][N];


int main() {
    cin >> n;
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= i; j++) {
            cin >> a[i][j];
        }
    }
    
    for(int i = 1; i <= n; i++) {
        for(int j = 0; j <= i + 1; j++) // 需要将每行边界附近的位置也初始化为-INF
            f[i][j] = -INF;
    }
    
    f[1][1] = a[1][1];
    for(int i = 2; i <= n; i++) { // 第一行已初始化，从第二行开始
        for(int j = 1; j <= i; j++) {
            f[i][j] = max(f[i - 1][j - 1] + a[i][j], f[i - 1][j] + a[i][j]);
        }
    }
    
    int res = -INF;
    for(int i = 1; i <= n; i++) res = max(res, f[n][i]);
    cout << res;
    
    return 0;
}
```

优化为一维动规：

```C++
#include <iostream>
#include <cstring>
using namespace std;

const int N = 510, INF = 1e9;
int n;
int a[N][N];
int f[N];


int main() {
    cin >> n;
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= i; j++) {
            cin >> a[i][j];
        }
    }
    
    for(int j = 0; j <= n + 1; j++) // 需要将每行边界附近的位置也初始化为-INF
        f[j] = -INF;
    
    f[1] = a[1][1];
    for(int i = 2; i <= n; i++) {
        for(int j = i; j >= 1; j--) {
            f[j] = max(f[j - 1] + a[i][j], f[j] + a[i][j]);
        }
    }
    
    int res = -INF;
    for(int i = 1; i <= n; i++) res = max(res, f[i]);
    cout << res;
    
    return 0;
}
```

**方法2：从下往上**

每个位置的最小值与其**左下角和右下角**的最小值有关，因而求左右两侧的点的最小值**不会用到三角形之外的点**，因而只需要保证第`n+1`行的元素全部为0即可，全局数组默认初始化为0，因而不需要单独初始化

```C++
#include <iostream>
#include <cstring>
using namespace std;

const int N = 510;
int n;
int a[N][N];
int f[N][N];


int main() {
    cin >> n;
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= i; j++) {
            cin >> a[i][j];
        }
    }
    
    for(int i = n; i >= 1; i--){
        for(int j = i; j >= 1; j--){
            f[i][j] = max(f[i + 1][j], f[i + 1][j + 1]) + a[i][j];
        }
    }
    cout<<f[1][1]<<endl;
    
    return 0;
}
```



#### 2. 最长上升子序列

【AcWing 895】给定一个长度为N的数列，求数值严格单调递增的子序列的长度最长是多少。

> 输入格式
> 第一行包含整数N。
> 第二行包含N个整数，表示完整序列。
> 输出格式
> 输出一个整数，表示最大长度。
> 数据范围
> 1≤N≤10001≤N≤1000，−109≤数列中的数≤109−109≤数列中的数≤109

```
输入样例：
7
3 1 2 1 8 5 6
输出样例：
4
```

**题解**：

- 状态集合：所有以第 i 个数结尾的上升子序列的长度

- 状态表示——`f[i]`：以第 i 个数结尾的上升子序列的长度的最大值
  - 状态集合`f(i)`分类：以第 i - 1个数（倒数第一个数）是哪个来分类
- 倒数第一个数可以为 `a[0]、a[1] ... a[i - 1]`

- 状态转移方程：`f[i] = max(f[j] + 1) | j = 0, 1, 2, ... , i-1`，即以第 i 个数结尾的上升子序列的长度为以第 i - 1个数结尾的上升子序列的长度+1，为了求最大值，需要枚举每个数结尾的上升子序列的长度，并求最大值。

```C++
#include <iostream>
using namespace std;

const int N = 1010;
int n;
int a[N];
int f[N];

int main() {
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> a[i];

    // 求以a[i]结尾的上升子序列的长度的最大值
    for(int i = 1; i <= n; i++) {
        f[i] = 1; // 只有a[i]一个数
        for(int j = 1; j < i; j++) {
            if(a[i] > a[j])
                f[i] = max(f[j] + 1, f[i]);
        }
    }
    int res = 0;
    for(int i = 1; i <= n; i++) res = max(res, f[i]); // 求所有上升子序列的最大值
    cout << res;
    return 0;
}
```



#### 3. 最长上升子序列II

#### 4. 最长公共子序列

#### 5. 编辑距离



### 区间DP

#### 1. 石子合并



### 计数类DP

#### 1. 整数划分



### 数位统计DP

#### 1. 计数问题



### 状态压缩DP

#### 1. 蒙德里安的梦想

#### 2. 最短Hamiton路径



### 树形DP

#### 1. 没有上司的舞会



### 记忆化搜索

#### 1. 滑雪



## 6、贪心

### 区间问题

#### 1. 区间选点

#### 2. 最大不想交区间数量

#### 3. 区间分组

#### 4. 区间覆盖



### Hufuman树

#### 1. 合并果子



# 二、数据结构学习笔记★

## 链表

### 单链表的创建

#### **1、头插法**

```C
Linklist Creat_list(Linklist head) {
	head = (Linklist)malloc(sizeof(Lnode));      //  为头指针开辟内存空间
	Lnode *node = NULL;                    //  定义新结点
	int count = 0;                          //  创建结点的个数
	head->next = NULL;              
	node = head->next;              	//  将最后一个结点的指针域永远保持为NULL
	printf("Input the node number: ");
	scanf("%d", &count);
	for (int i = 0; i < count; i++) {
		node = (Linklist)malloc(sizeof(Lnode));     //  为新结点开辟内存空间
		node->data = i;          //  为新结点的数据域赋值
		node->next = head->next; //  将头指针所指向的下一个结点的地址，赋给新创建结点的next 
		head->next = node;       //  将新创建的结点的地址赋给头指针的下一个结点
	}
	return head;
}
```

核心代码：

```C
node->next = head->next; //  将头指针所指向的下一个结点的地址，赋给新创建结点的next 
head->next = node;       //  将新创建的结点的地址赋给头指针的下一个结点
```

#### **2、尾插法**

```C
Linklist Creat_list(Linklist head) {
	head = (Linklist)malloc(sizeof(Lnode));          //  为头指针开辟内存空间
	Linklist node = NULL;           //  定义结点
	Linklist end = NULL;            //  定义尾结点
	head->next = NULL;              //  初始化头结点指向的下一个地址为 NULL
	end = head;                     //  未创建其余结点之前，只有一个头结点
	int count = 0 ;                 //  结点个数
	printf("Input node number: ");
	scanf("%d", &count);
	for (int i = 0; i < count; i++) {
		node = (Linklist)malloc(sizeof(Lnode));          //  为新结点开辟新内存
		node->data = i;                                  //  新结点的数据域赋值
		end->next = node;                      		
		end = node;
	}
	end->next = NULL;
}
```

核心代码：

```C
end->next = node;                      		
end = node;
```

[链表头插法及尾插法详解](https://blog.csdn.net/qq_41028985/article/details/82859199)

#### 单链表的读取

```C++
/*初始条件:单链表L已存在，1<=i<=ListLength(L)*/
/*操作结果:用e返回L中第i个数据元素的值*/
Status GetElem (ListNode *L, int i , ElemType *e) 
{
    int j = 1; // 计数器
    ListNode *p; // 声明一节点p
    p = L->next; // 让p指向L的第一个节点

    while (p && j<i) { // p不为空或者计数器还不等于i
        p = p->next; // 让p指向下一个节点
        ++j;
    }

    if ( !p || j>i )
    	return ERRO; // 第i个元素不存在
    *e = p->data; // 取第i个元素的数据
    return OK; 
}
```



#### 单链表的插入

```C++
/*初始条件:单链表L已存在，1<=i<=ListLength(L)*/
/*操作结果:在L中第i个位置之前插入新的元素e，L的长度加1*/
Status ListInsert (ListNode *L, int i , ElemType *e) {
    int j = 1;
    ListNode *p;
    ListNode *s;
    p = L;
    while(p && j < i) { // 寻找第i个节点
        p = p->next;
        ++j;
    }
    
    if(!p || j > i) { // 第i个元素不存在
        return ERROR;
    }
    s = (ListNode) malloc(sizeof(ListNode)); // 生成新节点
    s->data = e;
    s->next = p->next; // 将p的后继节点赋值给s的后继
    p->next = s; // 将s赋值给p的后继
    
    return OK;
}
```



#### 单链表的删除

```C++
/*初始条件:单链表L已存在，1<=i<=ListLength(L)*/
/*操作结果:删除L中第i个数据元素，并用e返回其值，L的长度减1*/
Status ListInsert (ListNode *L, int i , ElemType *e) {
    int j = 1;
    ListNode *p;
    ListNode *q;
    p = L;
    while(p->next && j < i) { // 寻找第i个节点
        p = p->next;
        ++j;
    }
    
    if(!p->next || j > i) { // 第i个元素不存在
        return ERROR;
    }
    q = p->next;
    p->next = q->next; // 将q的后继赋值给p的后继
    e = q->data; // 将q节点中的数据给e
    free(q); // 回收此节点
    
    return OK;
}
```



#### 反转单向和双向链表

【题目】 分别实现反转单向链表和反转双向链表的函数。
【要求】 如果链表长度为N，时间复杂度要求为O(N)，额外空间复杂度要求为O(1)

**图解**
现在有一个单向链表如下图所示：
<img src="https://gitee.com//MrRen-sdhm/Images/raw/master/img/20200509233611.png" alt="正向链表" style="zoom:67%;" />

反转后如下所示：
<img src="https://gitee.com//MrRen-sdhm/Images/raw/master/img/20200509233612.png" alt="反向链表" style="zoom:67%;" />

接下来解析反转函数：

<img src="https://gitee.com//MrRen-sdhm/Images/raw/master/img/20200509233613.png" alt="反转单向链表1"  />

第一步：next = head.next
将 head.next 赋值给 next 变量，也就是说 next 指向了节点2，先将节点2 保存起来。

第二步：head.next = pre
将 pre 变量赋值给 head.next，即 节点1 指向了 null

第三步：pre = head

将 head 赋值给了 pre，即 pre 指向节点1，将节点1 设为“上一个节点”

第四步：head = next

将 next 赋值给 head，即 head 指向了节点2。将节点2 设为“头节点”

第一次循环完毕，进入第二次循环，如下图
<img src="https://gitee.com//MrRen-sdhm/Images/raw/master/img/20200509233614.png" alt="反转单向链表2" style="zoom:67%;" />
第一步：next = head.next
将 head.next 赋值给 next 变量，也就是 next 指向了节点3，先将节点3 保存起来。

第二步：head.next = pre
将 pre 赋值给 head.next，pre 在上一次循环的时候指向了节点1，那么这一步的意义就是节点2 指向了 节点1，完成一次反转

第三步：pre = head

将 head 赋值给了 pre，即 pre 指向节点2，将节点2 设为“上一个节点”

第四步：head = next

将 next 赋值给 head，即 head 指向了节点3。将节点3 设为“头节点”

第二次循环完毕，以此类推！第三次第四次第五次循环。最后反转成如下图
<img src="https://gitee.com//MrRen-sdhm/Images/raw/master/img/20200509233615.webp" alt="完成反转" style="zoom:67%;" />

总结
保存当前头节点的下一个节点（当前头节点为2，先将节点3 保存起来）

将当前头节点的下一个节点指向 “上一个节点”（当前头节点2 指向了 (“上一个节点”)节点1），这一步才是实现反转

将当前头节点设置 “上一个节点”（将节点2 设为“上一个节点”）

将保存的下一个节点设置 “头节点”（将节点3 设为“头节点”）

```C++
// 反转单向链表
static Node* reverseList(Node *head) {
    Node *pre = nullptr;
    Node *next = nullptr;
    while (head != nullptr) {
        next = head->next;
        head->next = pre;
        pre = head;
        head = next;
    }
    return pre;
};
```

```C++
// 反转双向链表
static DoubleNode* reverseList(DoubleNode *head) {
    DoubleNode *pre = nullptr;
    DoubleNode *next = nullptr;
    while (head != nullptr) {
        next = head->next;
        head->next = pre;
        head->last = next; // 原先链表的下一个节点与上一个节点互换
        pre = head;
        head = next;
    }
    return pre;
}
```



## 二叉树

### 节点分类

树的结点包含一个数据元素及若干指向其子树的分支。**结点拥有的子树数称为结点的度**。度为 0 的结点称为叶结点(Leaf) 或终端结点；度不为 0 的结点称为非终端结点或分支结点。除根结点之外，分支结点也称为内部结点。**树的度是树内各结点的度的最大值**。



### 节点间的关系

结点的子树的根称为该结点的**孩子**(Child) ，相应地，该结点称为孩子的**双亲**(Parent)。同一个双亲的孩子之间直称兄弟 (Sibling) 。结点的**祖先**是从根到该结点所经分支上的所有结点，以某结点为根的子树中的任一结点都称为该结点的**子孙**。



### 二叉树的分类

#### 满二叉树

在一棵二叉树中，如果所有分支**结点都存在左子树和右子树**，并且**所有叶子都在同一层上**，这样的二叉树称为满二叉树。



#### 完全二叉树（堆）

对一棵具有 n 个结点的二叉树按层序编号，如果编号为 i (1 ≤ i ≤ n) 的结点与同样深度的满二叉树中编号为 i 的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树 。

- 大顶堆：根 >= 左 && 根 >= 右，即根节点大于等于子节点
- 小顶堆：根 <= 左 && 根 <= 右，即根节点小于等于子节点



### 二叉树的性质

1、在二叉树的第i层上至多有**2<sup>i-1</sup>**个节点(i ≥ 1)

2、深度为 k 的二叉树至多有 **2<sup>k</sup>-1** 个结点 (k ≥ 1)

3、对任一二叉树，其叶子结点数为n<sub>0</sub>，度为 2 的结点数为n<sub>2</sub>，则 **n<sub>0</sub>=n<sub>2</sub> + 1**，即叶子节点数=度为2节点数+1

4、具有 n 个结点的完全二叉树的深度为**⌊log<sub>2</sub>(n)⌋+1**，或**⌈log<sub>2</sub>(n+1)⌉**

5、如果对一棵有 n 个结点的完全二叉树(其深度为 ⌊log<sub>2</sub>(n)⌋+1) 的结点按层序编号（从第 1 层到第 ⌊log<sub>2</sub>(n)⌋+1   	  层，每层从左到右），对任一结点 i ( **1** ≤ i ≤ n-1 )有:

1. 如果 i=1，则结点 i 是二叉树的根，无双亲；如果i > 1，则其双亲是结点 **⌊i/2⌋**。**★**

2. 如果 2i>n，则结点 i 无左孩子（结点 i 为叶子结点）；否则其左孩子是结点**2i**。**★**

3. 如果 2i+1>n，则结点 i 无右孩子；否则其右孩子是结点 **2i+1**。**★**

   若结点 i ( **0** ≤ i ≤ n )有:   1. 双亲是结点 **⌊(i-1)/2⌋**  2. 左孩子是结点**2i+1**  3. 右孩子是结点 **2i+2**



### 二叉树的存储结构

- 顺序存储：一般只用于存储完全二叉树

- 二叉链表：由数据域及左右指针域组成

  ```c++
  typedef struct BiTNode // 节点结构
  {
      TElemType data; // 结点数据
      struct BiTNode *lchild, *rchild; // 左右孩子指针
  } BiTNode, *BLTree; 
  ```
  
- 表示方法：

  - 双亲表示法
  - 双亲孩子表示法
  - 孩子兄弟表示法

### 遍历二叉树

核心思想：递归

- 前序遍历：先访问根节点，然后先前序遍历根节点的左子树再前序遍历根节点的右子树

  ```c++
  void PreOrderTraverse (BiTree T) 
  {
      if (T==NULL)
      	return;     
      printf( "%c", T->data); // 显示结点数据
      PreOrderTraverse (T->lchild ) ; // 再先序遍历左子树
      PreOrderTraverse (T->rchild) ; // 最后先序遍历右子树
}
  ```

- 中序遍历：先中序遍历根节点的左子树，然后访问根节点，最后中序遍历根节点的右子树

  ```c++
  void InOrderTraverse (BiTree T) 
  {
      if (T==NULL)
      	return;
      InOrderTraverse (T->lchild ) ; // 中序遍历左子树
      printf( "%c", T->data); // 显示结点数据
      InOrderTraverse (T->rchild) ; // 最后中序遍历右子树
}
  ```

- 后序遍历：先后序遍历根节点的左子树，然后后序遍历根节点的右子树，最后访问根节点

  ```c++
  void PostOrderTraverse (BiTree T) 
  {
      if (T==NULL)
      	return;
      PostOrderTraverse (T->lchild ) ; // 先后序遍历左子树
      PostOrderTraverse (T->rchild) ; // 再后序遍历右子树
      printf( "%c", T->data); // 显示结点数据
}
  ```

- 层序遍历：从第一层开始从上到下逐层遍历，在同一层中从左到右对节点逐个访问

     - 需借助队列实现二叉树的层次遍历

- 性质：

     - 己知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树           
     - 已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树

### 建立二叉树

核心思想：递归

```c++
/* 按前序输入二叉树中节点的值 #表示空节点*/
void CreateBiTree (BiTree *T) 
{
    TElemType ch; 
    scanf ("%c", &ch) ; 
    if (ch == '#' )
    	*T = NULL; 
    else
    {
		*T = (BiTree) malloc(sizeof(BiTNode));
        if (!*T)
            exit(OVERFLOW);
        (*T)->data = ch; // 生成根节点
        CreateBiTree(&(*T)->lchild); // 构建左子树
        CreateBiTree(&(*T)->lchild); // 构建右子树
    }
}
```

### 线索二叉树

- 定义：指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树。

- 优点：线索二叉树等于是把一棵二叉树转属变成了一个双向链表 ，这样对我们的插入删除结点、查找某个结点都带来了方便。所以对二叉树以某种次序遍历使其变为线索二叉树的过程称做是线索化。

- 构建：在每个节点增设ltag和rtag来区分左右指针是指向左右孩子还是前驱后继。
  - ltag 为 0 时指向该结点的左孩子，为 1 时指向该结点的前驱。
  - rtag 为 0 时指向该结点的右孩子，为 1 时指向该结点的后继。

- 二叉树线索存储结构定义：

    ```C++
    // Link==O 表示指向左右孩子指针, Thread==l 表示指向前驱或后继的线索
    typedef enum {Link, Thread} PointerTag;

    typedef struct BiThrNode // 二叉线索存储节点结构

    TElernType data; // 节点数据
    struct BiThrNode *lchild, *rchild; // 左右孩子指针
    PointerTag LTag; // 右标志
    PöinterTag RTag; // 右标志
    } BiThrNode, *BiThrTree; 
    ```

### 哈夫曼树

- 路径及路径长度相关定义：
  - 路径及路径长度：从树中一个结点到另一个结点之间的分支构成两个结点之间的**路径** ，路径上的分支数目称做**路径长度**。
  - 树的路径长度：从树根到每一结点的路径长度之和。
  - 结点的带权路径长度：从该结点到树根之间的路径长度与结点上权的乘积。
  - 树的带权路径长度：树中所有叶子结点的带权路径长度之和 。

- **哈夫曼树**：带权路径长度 **WPL 最小**的二叉树称做赫夫曼树，也称最优二叉树。
  
  - 哈夫曼树构建方法：
    
    - 1、统计每个节点的权值(各元素出现的次数)，再按权值从小到大排序，得到一个有序序列，如A-6，
      E-10, B-15, D-30, C-40
    
    - 2、取头两个最小权值的结点作为一个新节点N1的两个子结点，注意相对较小的是左孩子，这里就是 A 为N1的左孩子，E 为 N1的右孩子。新节点N1的权值为两个子节点权值的和6+10=16
    - 3、用 N1替换 A 与 E，插入有序序列中，**保持从小到大排列** 。 即 : B-15, N1-16, D-30, C-40
    - 4、重复步骤2，取B和N1作为新节点N2的两个子节点。重复步骤3，用N2替换B与N1，插入有序序列，保持从小到大排列
  
- 哈夫曼编码：规定哈夫曼树的左分支代表 0 ，右分支代表 1 ，则从根结点到叶子结点所经过的路径分支组成的 0 和 1 的序列便为该结点对应字符的编码，这就是哈夫曼编码。 

#### 二叉排序树（二叉查找树）

二叉排序树 ( Binary Sort Tree)，又称为二叉查找树。它或者是一棵空树，或者是具有下列性质的二叉树

（左 < 根 < 右）。

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值 ;
- 若它的右子树不空 ，则右子树上所有结点的值均大于它的根结点的值;

- 它的左、右子树也分别为二叉排序树。

构建二叉排序树的目的是提高查找和插入删除关键字的速度。二叉排序树的查找性能取决于二叉排序树的形状，若二叉排序树是比较平衡的，其深度与完全二叉树相同，则查找的时间复杂度为**O(logn)**；若不平衡，最差情况下是一棵斜树，则时间复杂度为**O(n)**。

#### 平衡二叉树(AVL树)

定义：平衡二叉树，是一种**二叉排序树**，其中每一个节点的左子树和右子树的**高度差至多等于 1**，

| 左子树树高 - 右子树树高 | <= 1。

二叉树上结点的左子树深度减去右子树深度的值称为**平衡因子 BF** (Banlance Factor) 。

距离插入结点最近的，且平衡困子的绝对值大于 1 的结点为根的子树，称为**最小不平衡子树**。

平衡二叉树的调整：

- 当最小不平衡子树根结点的平衡因子 BF 是大于 1 时，就右旋，小于-1 时就左旋。
  - 插入结点后，最小不平衡子树的 BF 与它的子树的 BF 符号相反时，就需要对结点先进行一次旋转以使得符号相同后，再反向旋转一次才能够完成平衡操作。
  - LL型：根的左孩子右旋
  - RR型：根的右孩子左旋
  - LR型：根的左孩子左旋，再右旋
  - RL型：右孩子的左子树，先右旋，再左旋
  
  平衡二叉树查找、插入和删除的时间复杂度均为**O(logn)**。

### 红黑树

**定义**：红黑树（Red–black tree）是一种**自平衡**的**二叉搜索树**。

**性质**：

1. 节点是红色或黑色。
2. 根是黑色。
3. 所有叶子都是黑色（叶子是 NIL 节点）。
4. 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）（新增节点的父节点必须相同）
5. **从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点**。（新增节点必须为红）

   由性质5可得：如果一个结点存在黑子结点，那么该结点肯定有两个子结点。

![An example of a red-black tree](https://gitee.com//MrRen-sdhm/Images/raw/master/img/20200509233616.webp)

- 红黑树并不是一个完美平衡的二叉查找树，即左右子树的高度可能不等，但左子树和右子树的黑结点的层数是相等的，也即任意一个结点到到每个叶子结点的路径都包含数量相同的黑结点(性质5)。所以我们叫红黑树这种平衡为**黑色完美平衡**。

**调整**：

- **左旋**：以某个结点作为支点(旋转结点)，其<u>右子结点变为旋转结点的父结点</u>，<u>右子结点的左子结点变为旋转结点的右子结点</u>，左子结点保持不变。

  ![img](https://gitee.com//MrRen-sdhm/Images/raw/master/img/20200509233617.png)

- **右旋**：以某个结点作为支点(旋转结点)，其<u>左子结点变为旋转结点的父结点</u>，<u>左子结点的右子结点变为旋转结点的左子结点</u>，右子结点保持不变。

  ![img](https://gitee.com//MrRen-sdhm/Images/raw/master/img/20200509233618.png)

- **变色**：结点的颜色由红变黑或由黑变红。

  ------

  **左旋**只影响旋转结点和其**右子树**的结构，把右子树的结点往左子树挪了。
  **右旋**只影响旋转结点和其**左子树**的结构，把左子树的结点往右子树挪了。

  ​																											参考：[30张图带你彻底理解红黑树](https://www.jianshu.com/p/e136ec79235c)  [维基百科](https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91)

**红黑树与AVL树对比**：

- 红黑树不符合AVL树的平衡条件，左右子树的高度差可能大于1。
- 红黑树能够以O(log<sub>2</sub>n) 的时间复杂度进行搜索、插入、删除操作。
- 红黑是用非严格的平衡来换取增删节点时旋转次数的降低，任何不平衡都能在三次旋转之内解决。而AVL是严格平衡树，在增加或者删除节点的时候，旋转的次数通常比红黑树要多。所以红黑树的插入效率更高。
- 红黑树的查询性能略差于AVL树，因为红黑树可能比AVL树多一层，也就是说红黑树的查询性能最多比相同内容的AVL树多一次比较，但红黑树在插入和删除上远远好于AVL树，AVL树每次插入删除会进行大量的平衡度计算，而红黑树为了维持红黑性质所做的红黑变换和旋转的开销，相较于AVL树为了维持平衡的开销要小得多。
- 红黑树的算法时间复杂度虽然和AVL相同，但统计性能比AVL树更高。